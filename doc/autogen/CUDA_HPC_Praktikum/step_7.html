<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                 "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link href="stylesheet.css" rel="stylesheet" type="text/css">
  <link href="tabs.css" rel="stylesheet" type="text/css">
  <title>The step-7 tutorial program</title>
  <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
  <meta name="author" content="the blanc and blanc++ authors <authors@dealii.org>">
  <meta name="copyright" content="Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by the deal.II authors">
  <meta name="blanc++ version" content="1.0.0">
</head>
<body>
<div class="head">
  <h1 class="head">CUDA Lab Course Reference Manual 2013</h1>
</div>
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">The step-7 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> 
<table class="tutorial" width="100%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
      </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#ClassWaveForms">Class: WaveForms</a>
      <ul>
        <li><a href="#Functiongenerate_waveforms">Function: generate_waveforms</a>
        <li><a href="#Functionnormalize_waveforms">Function: normalize_waveforms</a>
        <li><a href="#Functionoriginal_waveforms">Function: original_waveforms</a>
      </ul>
        <li><a href="#Declarationsofthekernelwrapperfunctions">Declarations of the kernel-wrapper-functions</a>
        <li><a href="#Kernel__subtract_array_from_matrix">Kernel: __subtract_array_from_matrix</a>
        <li><a href="#Kernel__MM_scalar">Kernel: __MM_scalar</a>
        <li><a href="#Kernel__Det">Kernel: __Det</a>
        <li><a href="#Kernel__P_ij">Kernel: __P_ij</a>
        <li><a href="#Kernel__u_ij">Kernel: __u_ij</a>
        <li><a href="#Kernel__z_ij">Kernel: __z_ij</a>
      <ul>
        <li><a href="#Functionreduction">Function: reduction</a>
      </ul>
        <li><a href="#Kernel__sum_array">Kernel: __sum_array</a>
        <li><a href="#Kernel__sum_log_array">Kernel: __sum_log_array</a>
        <li><a href="#Kernel__sum_array2D">Kernel: __sum_array2D</a>
        <li><a href="#Kernel__y">Kernel: __y</a>
        <li><a href="#Kernel__MxM">Kernel: __MxM</a>
        <li><a href="#Kernel__SMX">Kernel: __SMX</a>
      <ul>
        <li><a href="#Functionsubtract_array_from_matrix">Function:subtract_array_from_matrix</a>
        <li><a href="#FunctionMM_scalar">Function: MM_scalar</a>
        <li><a href="#FunctionDet">Function: Det</a>
        <li><a href="#Functionassemble_P_ij">Function: assemble_P_ij</a>
        <li><a href="#Functionassemble_u_ij">Function: assemble_u_ij</a>
        <li><a href="#Functionassemble_z_ij">Function: assemble_z_ij</a>
        <li><a href="#Functioncalculate_y">Function: calculate_y</a>
        <li><a href="#Functionsum_array">Function: sum_array</a>
        <li><a href="#Functionsum_matrix_cols">Function: sum_matrix_cols</a>
        <li><a href="#Functionsum_array2D">Function: sum_array2D</a>
        <li><a href="#FunctionMxM">Function: MxM</a>
        <li><a href="#FunctionSMX">Function: SMX</a>
      </ul>
        <li><a href="#ClassShohamEM">Class: ShohamEM</a>
        <li><a href="#ClassKernelTest">Class: KernelTest</a>
        <li><a href="#StructRightMSolve">Struct: RightMSolve</a>
      <ul>
        <li><a href="#Operator">Operator: = </a>
      </ul>
        <li><a href="#StructRightMSolveTr">Struct: RightMSolveTr</a>
      <ul>
        <li><a href="#Operator">Operator: = </a>
        <li><a href="#Operator">Operator: *</a>
        <li><a href="#Operator">Operator: *</a>
        <li><a href="#ConstructorShohamEM">Constructor: ShohamEM</a>
        <li><a href="#Functiondump">Function: dump</a>
        <li><a href="#Functionrun_Shoham">Function: run_Shoham</a>
        <li><a href="#Functioninitialize_Shoham">Function: initialize_Shoham</a>
        <li><a href="#Functione_step_Shoham">Function: e_step_Shoham</a>
        <li><a href="#Functionm_step_Shoham">Function: m_step_Shoham</a>
        <li><a href="#Functionpurge_step_Shoham">Function: purge_step_Shoham</a>
        <li><a href="#DestructorShohamEM">Destructor : ~ShohamEM</a>
        <li><a href="#ConstructorKernelTest">Constructor: KernelTest</a>
        <li><a href="#Functionrun">Function: run</a>
        <li><a href="#DestructorKernelTest">Destructor : ~KernelTest</a>
      </ul>
        <li><a href="#ClassSimParams">Class: SimParams</a>
        <li><a href="#ClassPCA">Class: PCA</a>
        <li><a href="#ClassMyFancySimulation">Class: MyFancySimulation</a>
      <ul>
        <li><a href="#ConstructorPCA">Constructor: PCA</a>
        <li><a href="#Functionrun">Function: run</a>
        <li><a href="#Functionfactorize">Function: factorize</a>
        <li><a href="#Functiondeclare">Function: declare</a>
        <li><a href="#Functionget">Function: get</a>
        <li><a href="#Functiongenerate_waveforms">Function: generate_waveforms</a>
        <li><a href="#ConstructorMyFancySimulation">Constructor: MyFancySimulation</a>
        <li><a href="#Funktionrun">Funktion: run</a>
        <li><a href="#Funktionrun_cluster_analysis">Funktion: run_cluster_analysis</a>
        <li><a href="#Funktionrun_simulation">Funktion: run_simulation</a>
        <li><a href="#Funktionrun_kerneltest">Funktion: run_kerneltest</a>
        <li><a href="#Funktionmain">Funktion: main</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
      </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
    <ul>
        <li><a href="#plain-ClassWaveForms">Class: WaveForms</a>
      <ul>
        <li><a href="#plain-Functiongenerate_waveforms">Function: generate_waveforms</a>
        <li><a href="#plain-Functionnormalize_waveforms">Function: normalize_waveforms</a>
        <li><a href="#plain-Functionoriginal_waveforms">Function: original_waveforms</a>
      </ul>
        <li><a href="#plain-Declarationsofthekernelwrapperfunctions">Declarations of the kernel-wrapper-functions</a>
        <li><a href="#plain-Kernel__subtract_array_from_matrix">Kernel: __subtract_array_from_matrix</a>
        <li><a href="#plain-Kernel__MM_scalar">Kernel: __MM_scalar</a>
        <li><a href="#plain-Kernel__Det">Kernel: __Det</a>
        <li><a href="#plain-Kernel__P_ij">Kernel: __P_ij</a>
        <li><a href="#plain-Kernel__u_ij">Kernel: __u_ij</a>
        <li><a href="#plain-Kernel__z_ij">Kernel: __z_ij</a>
      <ul>
        <li><a href="#plain-Functionreduction">Function: reduction</a>
      </ul>
        <li><a href="#plain-Kernel__sum_array">Kernel: __sum_array</a>
        <li><a href="#plain-Kernel__sum_log_array">Kernel: __sum_log_array</a>
        <li><a href="#plain-Kernel__sum_array2D">Kernel: __sum_array2D</a>
        <li><a href="#plain-Kernel__y">Kernel: __y</a>
        <li><a href="#plain-Kernel__MxM">Kernel: __MxM</a>
        <li><a href="#plain-Kernel__SMX">Kernel: __SMX</a>
      <ul>
        <li><a href="#plain-Functionsubtract_array_from_matrix">Function:subtract_array_from_matrix</a>
        <li><a href="#plain-FunctionMM_scalar">Function: MM_scalar</a>
        <li><a href="#plain-FunctionDet">Function: Det</a>
        <li><a href="#plain-Functionassemble_P_ij">Function: assemble_P_ij</a>
        <li><a href="#plain-Functionassemble_u_ij">Function: assemble_u_ij</a>
        <li><a href="#plain-Functionassemble_z_ij">Function: assemble_z_ij</a>
        <li><a href="#plain-Functioncalculate_y">Function: calculate_y</a>
        <li><a href="#plain-Functionsum_array">Function: sum_array</a>
        <li><a href="#plain-Functionsum_matrix_cols">Function: sum_matrix_cols</a>
        <li><a href="#plain-Functionsum_array2D">Function: sum_array2D</a>
        <li><a href="#plain-FunctionMxM">Function: MxM</a>
        <li><a href="#plain-FunctionSMX">Function: SMX</a>
      </ul>
        <li><a href="#plain-ClassShohamEM">Class: ShohamEM</a>
        <li><a href="#plain-ClassKernelTest">Class: KernelTest</a>
        <li><a href="#plain-StructRightMSolve">Struct: RightMSolve</a>
      <ul>
        <li><a href="#plain-Operator">Operator: = </a>
      </ul>
        <li><a href="#plain-StructRightMSolveTr">Struct: RightMSolveTr</a>
      <ul>
        <li><a href="#plain-Operator">Operator: = </a>
        <li><a href="#plain-Operator">Operator: *</a>
        <li><a href="#plain-Operator">Operator: *</a>
        <li><a href="#plain-ConstructorShohamEM">Constructor: ShohamEM</a>
        <li><a href="#plain-Functiondump">Function: dump</a>
        <li><a href="#plain-Functionrun_Shoham">Function: run_Shoham</a>
        <li><a href="#plain-Functioninitialize_Shoham">Function: initialize_Shoham</a>
        <li><a href="#plain-Functione_step_Shoham">Function: e_step_Shoham</a>
        <li><a href="#plain-Functionm_step_Shoham">Function: m_step_Shoham</a>
        <li><a href="#plain-Functionpurge_step_Shoham">Function: purge_step_Shoham</a>
        <li><a href="#plain-DestructorShohamEM">Destructor : ~ShohamEM</a>
        <li><a href="#plain-ConstructorKernelTest">Constructor: KernelTest</a>
        <li><a href="#plain-Functionrun">Function: run</a>
        <li><a href="#plain-DestructorKernelTest">Destructor : ~KernelTest</a>
      </ul>
        <li><a href="#plain-ClassSimParams">Class: SimParams</a>
        <li><a href="#plain-ClassPCA">Class: PCA</a>
        <li><a href="#plain-ClassMyFancySimulation">Class: MyFancySimulation</a>
      <ul>
        <li><a href="#plain-ConstructorPCA">Constructor: PCA</a>
        <li><a href="#plain-Functionrun">Function: run</a>
        <li><a href="#plain-Functionfactorize">Function: factorize</a>
        <li><a href="#plain-Functiondeclare">Function: declare</a>
        <li><a href="#plain-Functionget">Function: get</a>
        <li><a href="#plain-Functiongenerate_waveforms">Function: generate_waveforms</a>
        <li><a href="#plain-ConstructorMyFancySimulation">Constructor: MyFancySimulation</a>
        <li><a href="#plain-Funktionrun">Funktion: run</a>
        <li><a href="#plain-Funktionrun_cluster_analysis">Funktion: run_cluster_analysis</a>
        <li><a href="#plain-Funktionrun_simulation">Funktion: run_simulation</a>
        <li><a href="#plain-Funktionrun_kerneltest">Funktion: run_kerneltest</a>
        <li><a href="#plain-Funktionmain">Funktion: main</a>
      </ul>
      </ul>
</ol> </td> </tr> </table>
 <a class="anchor" id="Introduction"></a></p>
<h1>Introduction</h1>
<p>To automatically classify the different shapes in the clustering problem, which we are facing in this project, we have the option to use the Gaussian mixture model algorithm to determine the cluster responsibilities. Although "recent studies have shown that the Gaussian model does not accurately capture the multivariate statistic of the waveform samples' distribution" <a href="http://dx.doi.org/10.1016%2fS0165-0270(03)00120-1">(Shy Shoham et al. 2003)</a>.<br/>
 In his publication "Robust, automatic spike sorting using mixtures of multivariate t-distributions" from 2003, Shoham presents "further data demonstrating non-Gaussian statistic, and show that the multivariate t-distribution,
a wide-tailed family of distributions, provides a significantly better fit to the true statistic".<br/>
 Furthermore Shoham provides an algorithm which "is statistically plausible, simple and well-behaved and can effectively deal with many real data sets". This algorithm is based on the mixture decomposition algorithm for multivariate t-distributions <a href="http://www.maths.uq.edu.au/%7Egjm/pm_sc00.pdf">(Peel and McLachlan, 2000)</a> which requires computation of twice as many hidden variables as in Gaussian mixture algorithms and also involves additional computation step for the 'degree of freedom' parameter.<br/>
 Instead of applying the algorithm directly, it would be applied in conjunction with an efficient model selection scheme developed by <a href="http://dx.doi.org/10.1109%2f34.990138">(Figueiredo and Jain, 2002)</a>, which maximize a penalized log-likelihood with penalty based on the minimum message length criterion <a href="http://links.jstor.org/sici?sici=0035-9246%281987%2949%3A3%3C240%3AEAIBCC%3E2.0.CO%3B2-M">(Wallace and Freeman, 1987)</a>. With this approach we get <img class="formulaInl" alt="$L_{p}$" src="form_43.png"/> noted below, where <img class="formulaInl" alt="$N$" src="form_44.png"/> is the number of parameters specifying each mixture component.[2]<br/>
</p>
<p>The complete algorithm goes as follows:<br/>
</p>
<p><b>Algorithm:<br/>
  </b></p>
<p><b> legend:<br/>
 </b>  </p>
<p><img class="formulaInl" alt="$p :=$" src="form_45.png"/> space dimension.<br/>
 <img class="formulaInl" alt="$g :=$" src="form_46.png"/> Number of cluster centers.<br/>
 <img class="formulaInl" alt="$g_{min} :=$" src="form_47.png"/> Minimal number of cluster centers.<br/>
 <img class="formulaInl" alt="$g_{max} :=$" src="form_48.png"/> Maximal number of cluster centers we are searching for.<br/>
 <img class="formulaInl" alt="$n :=$" src="form_49.png"/> Number of data points.<br/>
 <img class="formulaInl" alt="$N :=$" src="form_50.png"/> Number of parameters per mixture component.<br/>
 <img class="formulaInl" alt="$\pi_j :=$" src="form_51.png"/> relative frequency of cluster <img class="formulaInl" alt="$j$" src="form_52.png"/>.<br/>
 <img class="formulaInl" alt="$\Sigma_j :=$" src="form_53.png"/> Covariance matrix of the cluster <img class="formulaInl" alt="$j$" src="form_52.png"/>.<br/>
 <img class="formulaInl" alt="$\Delta_j := \sqrt{det(\Sigma_j)}$" src="form_54.png"/><br/>
 <img class="formulaInl" alt="$v :=$" src="form_55.png"/> Degree of freedom (DOF) parameter.<br/>
 <img class="formulaInl" alt="$L :=$" src="form_56.png"/> log-likelihood function.<br/>
</p>
<p><b>Initialization:</b> </p>
<ul>
<li>
use clustering method i.e K-means to determine centers <img class="formulaInl" alt="$\vec{\mu}_0 ,..., \vec{\mu}_{g-1}$" src="form_57.png"/> </li>
<li>
<img class="formulaInl" alt="$g = g_{max}$" src="form_58.png"/> </li>
<li>
Set <ul>
<li>
<img class="formulaInl" alt="$\pi_1 ,..., \pi_g = \frac{1}{g}$" src="form_59.png"/>, <img class="formulaInl" alt="$\pi \in \mathbb{K}^{g}$" src="form_60.png"/> </li>
<li>
<img class="formulaInl" alt="$\Sigma_1 ,..., \Sigma_g = I$" src="form_61.png"/>, <img class="formulaInl" alt="$\Sigma_j \in \mathbb{R}^{g \times g}$" src="form_62.png"/>, <img class="formulaInl" alt="$\Sigma \in \left (\mathbb{R}^{g \times g} \right )^{g}$" src="form_63.png"/> </li>
<li>
<img class="formulaInl" alt="$v = 50$" src="form_64.png"/> </li>
<li>
<img class="formulaInl" alt="$P_{ij}\in \mathbb{R}^{nxg}$" src="form_65.png"/> </li>
<li>
<img class="formulaInl" alt="$L_{max} = -\infty$" src="form_66.png"/> </li>
<li>
<img class="formulaInl" alt="$N$" src="form_44.png"/> </li>
<li>
<img class="formulaInl" alt="$x = \left \{ \vec{x}_0,...,\vec{x}_{n-1} \right \}$" src="form_67.png"/>, <img class="formulaInl" alt="$x \in \mathbb{R}^{p \times n}$" src="form_68.png"/> </li>
<li>
<img class="formulaInl" alt="$\mu = \left \{ \vec{\mu}_0,...,\vec{\mu}_{g-1} \right \}$" src="form_69.png"/>, <img class="formulaInl" alt="$\mu \in \mathbb{R}^{p \times g}$" src="form_70.png"/> </li>
<li>
<img class="formulaInl" alt="$\delta_{ij}:=\delta(\vec{x}_{i},\vec{\mu}_{j};\Sigma_{j})=(\vec{x}_{i}-\vec{\mu}_{j})^{T} I^{-1}(\vec{x}_{i}-\vec{\mu}_{j})$" src="form_71.png"/>  </li>
</ul>
</li>
</ul>
<p><br/>
 <b>Iteration:</b> </p>
<p><b>while</b> <img class="formulaInl" alt="$g \geq g_{min}$" src="form_72.png"/><br/>
<br/>
 &#160; &#160; <b>E-Step</b> </p>
<ul>
<li>
weighted squared distance between i-th datapoint and j-th cluster mean </li>
<li>
(Mahalanobis distance) </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\delta_{ij}:=\delta(\vec{x}_{i},\vec{\mu}_{j};\Sigma_{j})&amp;=&amp;(\vec{x}_{i}-\vec{\mu}_{j})^{T}\Sigma_{j}^{-1}(\vec{x}_{i}-\vec{\mu}_{j}) \end{eqnarray}" src="form_73.png"/>
</p>
<p><br/>
 </p>
<ul>
<li>
likelihood of i-th datapoint assigned to j-th cluster </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}P_{ij}&amp;=&amp;\frac{\Gamma(\frac{v+p}{2})}{\Gamma(\frac{v}{2})(\pi v)^{p/2}\Delta_j}\frac{1}{(1+\frac{\delta_{ij}}{v})^{(v+p)/2}} \end{eqnarray}" src="form_74.png"/>
</p>
<p><br/>
 </p>
<ul>
<li>
update <img class="formulaInl" alt="$L$" src="form_5.png"/> with </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}L_p = \sum_{i=1}^n \log \sum_{j=1}^g P_{ij}\pi_j -\left [ \frac{N}{2}\sum_{j=1}^{g} \log \frac{n\pi_j}{12}+\frac{g}{2}+\frac{g(N+1)}{2} \right ] \end{eqnarray}" src="form_75.png"/>
</p>
<p><br/>
 &#160; &#160; <b>if</b> <img class="formulaInl" alt="$(\Delta L < 0.1 \&amp; \Delta v < 10^{-2})$" src="form_76.png"/>: convergence reached<br/>
 &#160; &#160; &#160; &#160; <b>return;</b><br/>
 </p>
<ul>
<li>
update memberships </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\hat{z}_{ij}&amp;=&amp;\frac{P_{ij} \pi_j}{\sum_{l=1}^{g} P_{il} \pi_l} \end{eqnarray}" src="form_77.png"/>
</p>
<p><br/>
 </p>
<ul>
<li>
and the weights </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\hat{u}_{ij}&amp;=&amp;\frac{p+v}{\delta_{ij}+v} \end{eqnarray}" src="form_78.png"/>
</p>
<p><br/>
 </p>
<ul>
<li>
calculate <img class="formulaInl" alt="$y$" src="form_23.png"/> wich is needed to determine the parameter <img class="formulaInl" alt="$v$" src="form_79.png"/> </li>
</ul>
<p><br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} y \equiv -\sum_{i=1}^{n}\sum_{j=1}^{g}\hat{z}_{ij}\left [\psi\left(\frac{p+v_{old}}{2} \right)+ \log \left(\frac{2}{\delta_{ij}+v_{old}} \right)-\hat{u}_{ij} \right ]/n \end{eqnarray}" src="form_80.png"/>
</p>
<p><br/>
</p>
<p>&#160; &#160; <b>M-Step</b><br/>
 &#160; &#160; &#160; &#160; <b>while</b> <img class="formulaInl" alt="$|\sum_{j=1}^{g}\pi_j -1|>{10}^{-4}$" src="form_81.png"/><br/>
 &#160; &#160; &#160; &#160; &#160; &#160; <b>For</b> <img class="formulaInl" alt="$j=1:g$" src="form_82.png"/><br/>
 </p>
<ul>
<li>
Update <img class="formulaInl" alt="$\pi_j$" src="form_83.png"/> with </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray} \pi_{j}^{(k)}&amp;=&amp;\frac{max\left(\sum_{i=1}^{n}\frac{P_{ij}\pi_j^{(k-1)}}{\sum_{l=1}^{g}P_{il}\pi_l^{(k-1)}}-\frac{N}{2},0 \right )}{n-\frac{gN}{2}} \end{eqnarray}" src="form_84.png"/>
</p>
<p><br/>
 </p>
<ul>
<li>
update <img class="formulaInl" alt="$g$" src="form_85.png"/> with number of <img class="formulaInl" alt="$\pi_j>0$" src="form_86.png"/> </li>
</ul>
<p>&#160; &#160; &#160; &#160; &#160; &#160; <b>End For</b><br/>
 &#160; &#160; &#160; &#160; <b>End While</b><br/>
 </p>
<ul>
<li>
Purge components where <img class="formulaInl" alt="$\pi_j = 0$" src="form_87.png"/> </li>
<li>
calculate new cluster means <img class="formulaInl" alt="$\mu$" src="form_88.png"/> and their respective standard deviation <img class="formulaInl" alt="$\Sigma$" src="form_89.png"/> with </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\mu_j &amp;=&amp; \frac{\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}\vec{x}_{i}}{\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}} \end{eqnarray}" src="form_90.png"/>
</p>
<p><br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\Sigma_j &amp;=&amp; \frac{\sum_{i=1}^{n}(\hat{z}_{ij}\hat{u}_{ij})(\vec{x}_i - \vec{\mu}_j)(\vec{x}_i - \vec{\mu}_j)^T}{\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}} \end{eqnarray}" src="form_91.png"/>
</p>
<p><br/>
 <br/>
 </p>
<ul>
<li>
using Cholesky decomposition leads to </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\Sigma_j=L^TL\end{eqnarray}" src="form_92.png"/>
</p>
<p><br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}\Delta_j &amp;=&amp; \sqrt{det(\Sigma_j)}=\prod_i L_{ii} \end{eqnarray}" src="form_93.png"/>
</p>
<p><br/>
 </p>
<ul>
<li>
update <img class="formulaInl" alt="$v$" src="form_79.png"/> </li>
</ul>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}v_{new}&amp;=&amp;\frac{2}{y+\log y-1}+0.0416 \left(1+erf \left(0.6594*\log \left(\frac{2.1971}{y+\log y-1} \right) \right) \right) \nonumber \\ \end{eqnarray}" src="form_94.png"/>
</p>
<p><br/>
 &#160; &#160; &#160; &#160; <b>If</b> <img class="formulaInl" alt="$L > L_{max}$" src="form_95.png"/><br/>
 </p>
<ul>
<li>
<img class="formulaInl" alt="$L_{max}=L$" src="form_96.png"/> </li>
<li>
Store parameters { <img class="formulaInl" alt="$\pi,\mu,\Sigma$" src="form_97.png"/>} as 'optimal' </li>
<li>
Set smallest component to zero (regarding to their <img class="formulaInl" alt="$\pi$" src="form_98.png"/> value) </li>
<li>
<img class="formulaInl" alt="$g=g-1$" src="form_99.png"/> </li>
</ul>
<p>&#160; &#160; &#160; &#160; <b>Else</b><br/>
 </p>
<ul>
<li>
<b>break;</b> </li>
</ul>
<p>&#160; &#160; &#160; &#160; <b>End if</b><br/>
 <b>End While</b><br/>
 </p>
<p>Literature:<br/>
 1. <a href="http://www.bm.technion.ac.il/Labs/niel/Public%20Data/Publications/Shoham_etal_JNM2003.pdf">Robust, automatic spike sorting using mixtures of multivariate t-distributions (Shy Shoham et al., 2003)</a><br/>
 2. <a href="http://www.lx.it.pt/~mtf/IEEE_TPAMI_2002.pdf ">Unsupervised Learning of Finite Mixture Models (Figueirdo and Jain, 2002)</a><br/>
 </p>
<p><b>Parallelzation structure:</b><br/>
</p>
<p>In this paragraph we discuss how we intend to implement each Kernel needed for the individual equations.<br/>
 <br/>
 <b><em> <img class="formulaInl" alt="$P_{ij}$" src="form_100.png"/> Kernel equation</em></b><br/>
 first we split the equation in three parts:<br/>
 </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray}P_{ij}&amp;=&amp;\frac{\Gamma(\frac{v+p}{2})}{\Gamma(\frac{v}{2})(\pi v)^{p/2}}\cdot\frac{1}{\Delta_j}\cdot\frac{1}{(1+\frac{\delta_{ij}}{v})^{(v+p)/2}} \end{eqnarray}" src="form_101.png"/>
</p>
<p><br/>
 The first part: <img class="formulaInl" alt="$\gamma := \frac{\Gamma(\frac{v+p}{2})}{\Gamma(\frac{v}{2})(\pi v)^{p/2}}$" src="form_102.png"/> should be pre-calculated using the CPU and would be handed out to the Kernel as an argument.<br/>
 <br/>
 The second part: <img class="formulaInl" alt="$\frac{1}{\Delta_j}$" src="form_103.png"/> with <img class="formulaInl" alt="$\Delta_j$" src="form_104.png"/> being a pointer on a small array with <img class="formulaInl" alt="$\sqrt{det \Sigma_j}$" src="form_105.png"/><br/>
 <br/>
 For the last part: <img class="formulaInl" alt="$\frac{1}{(1+\frac{\delta_{ij}}{v})^{(v+p)/2}}$" src="form_106.png"/> each <img class="formulaInl" alt="$\delta_{ij}$" src="form_107.png"/> would be loaded exactly once.<br/>
 <br/>
 Therefor our function parameter for the kernel are:<br/>
 </p>
<ul>
<li>
<img class="formulaInl" alt="$\{\gamma, v , p\} \in \mathbb{R}$" src="form_108.png"/> </li>
<li>
<img class="formulaInl" alt="$n, g$" src="form_109.png"/> as space dimension </li>
<li>
const T * Delta <img class="formulaInl" alt="$\in \mathbb{R}^{g}$" src="form_110.png"/> </li>
<li>
const T * delta <img class="formulaInl" alt="$\in \mathbb{R}^{n \times g}$" src="form_111.png"/> </li>
<li>
T * const P_ij <img class="formulaInl" alt="$\in \mathbb{R}^{n \times g}$" src="form_111.png"/> </li>
</ul>
<p>For the thread and Grid dimensions we choose<br/>
 </p>
<ul>
<li>
1-dimensional threadblocks to handel the column sections </li>
<li>
2-dimensional thread-Grids with: <ul>
<li>
gridDim.x = column index --&gt; which <img class="formulaInl" alt="$\Delta_j$" src="form_104.png"/> </li>
<li>
gridDim.y = top row of the threadblock </li>
</ul>
The indices <img class="formulaInl" alt="$i$" src="form_112.png"/> and <img class="formulaInl" alt="$j$" src="form_52.png"/> would be:<br/>
 </li>
<li>
<img class="formulaInl" alt="$I = $" src="form_113.png"/> gridDim.y * blockDim.x + threadIdx.x </li>
<li>
<img class="formulaInl" alt="$j = $" src="form_114.png"/> gridDim.x </li>
</ul>
<p>Finally we calculate <img class="formulaInl" alt="$P_{ij}$" src="form_100.png"/> and store it in the P_ij Matrix.<br/>
 </p>
<p><b><em> <img class="formulaInl" alt="$\frac {\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}\vec{x}_i}{\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}}$" src="form_115.png"/> Kernel function</em></b><br/>
 first we split the equation in two parts:<br/>
 The denominator: <img class="formulaInl" alt="$\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}$" src="form_116.png"/> is calculated with the sum_array2D Kernel.<br/>
 <br/>
 The numerator: <img class="formulaInl" alt="$\sum_{i=1}^{n}\hat{z}_{ij}\hat{u}_{ij}\vec{x}_i$" src="form_117.png"/> present a challenge in loading the vector <img class="formulaInl" alt="$x_i$" src="form_118.png"/> only once and calculating the sum of the matrices which are created by the vector product of <img class="formulaInl" alt="$\hat{z}_{ij}\hat{u}_{ij} \vec{x}_i$" src="form_119.png"/><br/>
 <br/>
 So we calculate the following:<br/>
 <img class="formulaInl" alt="$\mu = \begin{bmatrix} . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ . &amp; . &amp; . &amp; . &amp; . \\ \end{bmatrix} = \begin{pmatrix} .\\ .\\ .\\ \vec{x}_i\\ \in\\ \mathbb{R}^p\\ .\\ .\\ .\\ \end{pmatrix} \cdot (\hat{z}_{i0}\hat{u}_{i0},...,\hat{z}_{ig}\hat{u}_{ig})\in \mathbb{R}^g + \begin{pmatrix} .\\ .\\ .\\ \vec{x}_{i+1}\\ \in\\ \mathbb{R}^p\\ .\\ .\\ .\\ \end{pmatrix} \cdot (\hat{z}_{i+1 0}\hat{u}_{i+1 0},...,\hat{z}_{i+1g}\hat{u}_{i+1g})\in \mathbb{R}^g + ...$" src="form_120.png"/><br/>
</p>
<p>Therefore our function parameter for the kernel are:<br/>
 </p>
<ul>
<li>
<img class="formulaInl" alt="$n, g, p$" src="form_121.png"/> as space dimension <img class="formulaInl" alt="$\in \mathbb{Z}$" src="form_122.png"/> </li>
<li>
const T * z_ij <img class="formulaInl" alt="$\in \mathbb{R}^{n \times g}$" src="form_111.png"/> </li>
<li>
const T * u_ij <img class="formulaInl" alt="$\in \mathbb{R}^{n \times g}$" src="form_111.png"/> </li>
<li>
const T * x <img class="formulaInl" alt="$\in \mathbb{R}^{n \times p}$" src="form_123.png"/> </li>
<li>
T * <img class="formulaInl" alt="$\mu \in \mathbb{R}^{g \times p}$" src="form_124.png"/> </li>
</ul>
<p>For the threadblock and Grid dimensions we choose<br/>
 </p>
<ul>
<li>
3-dimensional threadblocks with: <ul>
<li>
blockDim.x = handle the <img class="formulaInl" alt="$i$" src="form_112.png"/> components of the <img class="formulaInl" alt="$x$" src="form_22.png"/> array.<br/>
 </li>
<li>
blockDim.y = the <img class="formulaInl" alt="$g$" src="form_85.png"/> components of the <img class="formulaInl" alt="$\hat{z}_{ij}\hat{u}_{ij}$" src="form_125.png"/><br/>
 </li>
<li>
blockDim.z = the <img class="formulaInl" alt="$p$" src="form_126.png"/> components.<br/>
 </li>
<li>
since we want to start 512 threads the blocksize will be dim3(32,4,4); </li>
<li>
32 refers to the number of threads in one warp which will enable us to easily calculate the sum of the individual portions. </li>
<li>
since we have no option to get the space dimensions <img class="formulaInl" alt="$p , g$" src="form_127.png"/> during the compilation time, we portion the number of data points in 4 data points in each direction </li>
</ul>
</li>
<li>
3-dimensional thread-Grids with: <ul>
<li>
gridDim.x = 32  </li>
<li>
gridDim.y = (g+4-1)/4  </li>
<li>
gridDim.z = (p+4-1)/4  </li>
</ul>
</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p>
<h1>The commented program</h1>
<div class="fragment"><pre class="fragment">     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef WAVEFORMS_GENERATOR_H</span>
<span class="preprocessor"></span><span class="preprocessor"> #define WAVEFORMS_GENERATOR_H</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;time.h&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
<span class="preprocessor"> #include &lt;QDir&gt;</span>
<span class="preprocessor"> #include &lt;QString&gt;</span>
<span class="preprocessor"> #include &lt;QVector&gt;</span>
</pre></div><p>boost random generator</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;boost/random/mersenne_twister.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/random/normal_distribution.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/random/variate_generator.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/random/uniform_real.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/math/distributions/students_t.hpp&gt;</span>
</pre></div><p><a class="anchor" id="ClassWaveForms"></a> </p>
<h3>Class: WaveForms</h3>
<p>Generates the initial Test data</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>WaveForms{
 
 <span class="keyword">public</span>:
     WaveForms();
</pre></div><p><a class="anchor" id="Functiongenerate_waveforms"></a> </p>
<h4>Function: generate_waveforms</h4>
<p>This function generates the initial waveforms for testing the ShohamEM algorithm</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>: number of rows (number of waves) </td></tr>
    <tr><td class="paramname">col</td><td>: number of columns (space dimension) </td></tr>
    <tr><td class="paramname">waveforms</td><td>: the matrix where the data are written </td></tr>
    <tr><td class="paramname">n_waves</td><td>: number of waves from each form </td></tr>
    <tr><td class="paramname">S</td><td>: noise intensity </td></tr>
    <tr><td class="paramname">waves_parameter</td><td>: conataints the parameter needed for generating the diffrent waveforms</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
     <span class="keyword">static</span> <span class="keywordtype">void</span> generate_waveforms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row,
                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col,
                                    dealii::FullMatrix&lt;D&gt; &amp;waveforms,
                                    <span class="keyword">const</span> std::vector&lt;int&gt; &amp;n_waves,
                                    D S,
                                    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;waves_parameter)
     {
</pre></div><p>random number generator, generates numbers between -1. and 1.</p>
<div class="fragment"><pre class="fragment">         boost::mt19937 rng;
         boost::uniform_real&lt;D&gt; u(-1., 1.);
         boost::variate_generator&lt;boost::mt19937&amp;, boost::uniform_real&lt;D&gt; &gt; gen(rng, u);
</pre></div><p>random number generator, generates numbers between 0. and 1.</p>
<div class="fragment"><pre class="fragment">         boost::mt19937 rng2;
         boost::uniform_real&lt;D&gt; v(0., 1.);
         boost::variate_generator&lt;boost::mt19937&amp;, boost::uniform_real&lt;D&gt; &gt; gen2(rng2, v);
 
 
         <span class="keywordtype">double</span> form;
         <span class="keywordtype">int</span> form_id;
         <span class="keywordtype">double</span> X, X1, X2, sig, sig1, sig2, nu, t, Y, noise, l, t0;
         <span class="keywordtype">double</span> P0,P1,P2,P3,P4,P5,P6;
</pre></div><p>store the waveforms parameter in different variables</p>
<div class="fragment"><pre class="fragment">         P0 = waves_parameter[0];
         P1 = waves_parameter[1];
         P2 = waves_parameter[2];
         P3 = waves_parameter[3];
         P4 = waves_parameter[4];
         P5 = waves_parameter[5];
         P6 = waves_parameter[6];
</pre></div><p>for each row/datapoint determine which form to write by calculating the commonness of each form</p>
<div class="fragment"><pre class="fragment">         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; row ; j++){
 
             form = gen2();
 
             <span class="keywordflow">if</span>(form&lt;(n_waves[0]/(<span class="keywordtype">double</span>)row))
                 form_id=1;
             <span class="keywordflow">else</span>{
                 <span class="keywordflow">if</span>(form &gt; ((n_waves[0]+n_waves[1])/(<span class="keywordtype">double</span>)row))
                     form_id = 3;
                 <span class="keywordflow">else</span>
                     form_id= 2;
             }
</pre></div><p>using the switch instruction and the calculated form ID, decide which form is to be written in the j_th row.</p>
<div class="fragment"><pre class="fragment">             <span class="keywordflow">switch</span>(form_id){
</pre></div><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} Y = \frac{1}{\tau} \ast \left(x-x_{0}\right)\exp-\left(\frac{x-x_{0}}{\sigma_{0}\sqrt{2}}\right)^2 + R \end{equation}" src="form_128.png"/>
</p>
<div class="fragment"><pre class="fragment">             <span class="keywordflow">case</span> 1:{
                 noise = 1+(gen()*S);
 
                 X = P0*(noise);
                 sig = P1*(noise);
                 t = 0.1*(noise);
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     Y = gen()*S;
                     l = k/double(col);
                     waveforms(j,k) = (1+Y)+(1/t)*((l-X)*exp(-(std::pow(((l-X)/(sig*sqrt(2))),2))));
                 }
                 <span class="keywordflow">break</span>;
             }
</pre></div><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} Y = cos^2(\frac{t-t_0+\tau}{\tau}*\pi) \end{equation}" src="form_129.png"/>
</p>
<div class="fragment"><pre class="fragment">             <span class="keywordflow">case</span> 2:{
 
                 noise = (gen() * S);
                 t0 = P2*double(col);
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
 
                     t = 12;
                     <span class="keywordflow">if</span>(k &lt; t0-t/2 || k &gt; t0+t/2)
                         waveforms(j,k) = 0.0;
                     <span class="keywordflow">else</span>
                         waveforms(j,k) = (1 + noise) * std::pow(cos(((k - t0 + t * noise) / t) * M_PI), 2);
                     waveforms(j,k)   += gen() * S;
                 }
 
 
                 <span class="keywordflow">break</span>;
             }
</pre></div><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} Y = \frac{1}{1+\left(\frac{x-x_{0}}{\sigma_{0}}\right)^2} - \frac{1}{1+\left(\frac{x-x_{1}}{\sigma_{1}}\right)^2} + R \end{equation}" src="form_130.png"/>
</p>
<div class="fragment"><pre class="fragment">             <span class="keywordflow">case</span> 3:{
 
                 noise = 1+(gen()*S)*0.5;
 
                 X1 = P3*noise;
                 sig1 = P5*noise;
                 t = noise;
                 X2 = P4*noise;
                 sig2 = P6*noise;
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     Y = gen()*S;
                     l = k/double(col);
                     waveforms(j,k) = (1+Y)+(1/t)*(((1/(1+std::pow(((l-X1)/sig1),2))) - (1/(1+std::pow(((l-X2)/sig2),2)))));
                 }
                 <span class="keywordflow">break</span>;
             }
             <span class="keywordflow">default</span>:{
                 std::cout&lt;&lt;<span class="stringliteral">&quot;illegal waveform choosen&quot;</span>&lt;&lt;std::endl;
             }
 
             }
         }
     }
</pre></div><p><a class="anchor" id="Functionnormalize_waveforms"></a> </p>
<h4>Function: normalize_waveforms</h4>
<p>This function normalizes the generated waveforms in respect to the X axis</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n_rows</td><td>: number of rows/datapoints. </td></tr>
    <tr><td class="paramname">n_cols</td><td>: number of columns (space dimension). </td></tr>
    <tr><td class="paramname">waveforms</td><td>: the matrix containing the generated waveforms.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
     <span class="keyword">static</span> <span class="keywordtype">void</span> normalize_waveforms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_rows, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cols,
                                     dealii::FullMatrix&lt;D&gt; &amp;waveforms)
     {
         <span class="keywordtype">double</span> row_sum, row_mean;
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n_rows; i++){
             row_sum = 0., row_mean = 1.;
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n_cols; j++){
                 row_sum += waveforms(i,j);
             }
             row_mean = row_sum/(double)n_cols;
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n_cols; j++){
                 waveforms(i,j) -= row_mean;
             }
         }
     }
</pre></div><p><a class="anchor" id="Functionoriginal_waveforms"></a> </p>
<h4>Function: original_waveforms</h4>
<p>This function generates one waveform from each one of the three available forms those will be used as the real means for the ShohamEM algorithm</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">col</td><td>: number of columns (space dimension). </td></tr>
    <tr><td class="paramname">n_forms</td><td>: number of forms choosen by the user. </td></tr>
    <tr><td class="paramname">check_waves</td><td>: the matrix where the data is written to. </td></tr>
    <tr><td class="paramname">waves_parameter</td><td>: conataints the parameter needed for generating the diffrent waveforms. </td></tr>
    <tr><td class="paramname">n_waves</td><td>: number of waves from each waveform.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
     <span class="keyword">static</span> <span class="keywordtype">void</span> original_waveforms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col, <span class="keywordtype">int</span> n_forms,
                                    dealii::FullMatrix&lt;D&gt; &amp;check_waves,
                                    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;waves_parameter,
                                    <span class="keyword">const</span> std::vector&lt;int&gt; &amp;n_waves)
     {
         <span class="keywordtype">double</span> X, X1, X2, sig, sig1, sig2, nu, t, noise, l;
         <span class="keywordtype">double</span> P0,P1,P2,P3,P4,P5,P6;
 
         P0 = waves_parameter[0];
         P1 = waves_parameter[1];
         P2 = waves_parameter[2];
         P3 = waves_parameter[3];
         P4 = waves_parameter[4];
         P5 = waves_parameter[5];
         P6 = waves_parameter[6];
 
         <span class="keywordtype">int</span> w1, w2, w3;
 
         w1 = n_waves[0];
         w2 = n_waves[1];
         w3 = n_waves[2];
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n_forms;i++){
             <span class="keywordflow">if</span>(w1!= 0 &amp;&amp; i&lt;n_forms){
                 X = P0;
                 sig = P1;
                 t = 0.1;
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     l = k/double(col);
                     check_waves(i,k) = (1/t)*((l-X)*exp(-(std::pow(((l-X)/(sig*sqrt(2))),2))));
                 }
                 w1 = 0;
                 i ++;
             }
             <span class="keywordflow">if</span>(w2!=0 &amp;&amp; i&lt;n_forms){
 
                 nu = P2;
                 X = (1/(nu*2));
                 l= 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     l = k/double(col) + noise;
                     <span class="keywordflow">if</span>(l &gt; 2*X|| l &lt; 0 ){
                         check_waves(i,k) = 0.;
                     }<span class="keywordflow">else</span>{
                         check_waves(i,k) = std::pow(sin(nu*M_PI*l),2);
                     }
                 }
                 w2 =0;
                 i++;
             }
             <span class="keywordflow">if</span>(w3!=0 &amp;&amp; i&lt;n_forms){
 
                 X1 = P3;
                 sig1 = P5;
                 X2 = P4;
                 sig2 = P6;
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     l = k/double(col);
                     check_waves(i,k) = (((1/(1+std::pow(((l-X1)/sig1),2))) - (1/(1+std::pow(((l-X2)/sig2),2)))));
                 }
                 w3 = 0;
                 i++;
             }
         }
     }
 };
 
 
<span class="preprocessor"> #endif // WAVEFORMS_GENERATOR_H</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef CUDA_KERNEL_STEP_7_CU_H</span>
<span class="preprocessor"> #define CUDA_KERNEL_STEP_7_CU_H</span>
</pre></div><p><a class="anchor" id="Declarationsofthekernelwrapperfunctions"></a> </p>
<h3>Declarations of the kernel-wrapper-functions</h3>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 <span class="keyword">struct </span>Kernel {
 
     <span class="keywordtype">void</span> subtract_array_from_matrix(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> g,
                                     <span class="keyword">const</span> T * X,
                                     <span class="keyword">const</span> T * mu_j,
                                     T * M);
 
     <span class="keywordtype">void</span> MM_scalar(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                    <span class="keyword">const</span> T * A,
                    <span class="keyword">const</span> T * B,
                    T * result);
 
     T Det(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> MS, <span class="keyword">const</span> T * A);
 
 
 
     <span class="keywordtype">void</span> assemble_P_ij(T gamma,
                        T v,
                        <span class="keywordtype">int</span> p,<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * Delta,
                        <span class="keyword">const</span> T * delta,
                        T * P_ij);
 
 
     <span class="keywordtype">void</span> assemble_u_ij(T v,
                        <span class="keywordtype">int</span> p,<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * delta,
                        T * u_ij);
 
     <span class="keywordtype">void</span> assemble_z_ij(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * P_ij,
                        <span class="keyword">const</span> T * c,
                        <span class="keyword">const</span> T * pi,
                        T * z_ij);
 
     <span class="keywordtype">void</span> reduce(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,
                 <span class="keyword">const</span> T * c,
                 T * result,
                 <span class="keywordtype">int</span> threads,
                 <span class="keywordtype">int</span> blocks);
 
     <span class="keywordtype">double</span> calculate_y(<span class="keywordtype">int</span> n,
                        <span class="keywordtype">int</span> g,
                        T v,
                        T digamma,
                        <span class="keyword">const</span> T * z_ij,
                        <span class="keyword">const</span> T * delta_ij,
                        <span class="keyword">const</span> T * u_ij);
 
     <span class="keywordtype">double</span> sum_array(<span class="keywordtype">int</span> n,
                      <span class="keyword">const</span> T * input,
                      <span class="keywordtype">bool</span> log);
 
     <span class="keywordtype">void</span> sum_matrix_cols(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * input,
                          T * output,
                          <span class="keywordtype">bool</span> log);
 
     <span class="keywordtype">double</span> sum_array(<span class="keywordtype">int</span> n,
                      <span class="keywordtype">int</span> g,
                      <span class="keyword">const</span> T * input,
                      <span class="keywordtype">bool</span> log);
 
     <span class="keywordtype">void</span> sum_array2D(<span class="keywordtype">int</span> n,
                      <span class="keywordtype">int</span> g,
                      <span class="keyword">const</span> T * z_ij,
                      <span class="keyword">const</span> T * u_ij,
                      T * output);
 
     <span class="keywordtype">void</span> MxM(<span class="keywordtype">int</span> n,<span class="keywordtype">int</span> g,
              <span class="keyword">const</span> T * z_ij,
              <span class="keyword">const</span> T * u_ij,
              T * q_ij);
 
     <span class="keywordtype">void</span> SMX(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
              <span class="keyword">const</span> T * q_ij,
              <span class="keyword">const</span> T C_j,
              <span class="keyword">const</span> <span class="keywordtype">int</span> j,
              <span class="keyword">const</span> T * X,
              <span class="keyword">const</span> T * mu_j,
              T * M);
 
 };
 
<span class="preprocessor"> #endif // CUDA_KERNEL_STEP_7_CU_H</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
</pre></div><p>Header-File of the CUDA utility-Library.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;step-7/cuda_kernel_wrapper_step-7.cu.h&gt;</span>
 
<span class="preprocessor"> #include &lt;math.h&gt;</span>
<span class="preprocessor"> #include &lt;stdio.h&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
 
 <span class="keywordtype">float</span> Giga_bytes = std::pow(1024.,3);
 
 cudaEvent_t beginEvent;
 cudaEvent_t endEvent;
 
 std::ofstream dt(<span class="stringliteral">&quot;output/Memory_Bandwidth.txt&quot;</span>);
</pre></div><p><a class="anchor" id="Kernel__subtract_array_from_matrix"></a> </p>
<h3>Kernel: __subtract_array_from_matrix</h3>
<p>Subtracts the array <code>mu_j</code> from each row of the matrix <code>X</code> . The results are saved in the output matrix <code>M</code> .</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __subtract_array_from_matrix(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> g,
                                              <span class="keyword">const</span> T * X,
                                              <span class="keyword">const</span> T * mu_j,
                                              T * M)
 {
     <span class="keywordtype">int</span> r = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> c = blockIdx.x;
 
     <span class="keywordflow">if</span>(r &lt; n &amp;&amp; c &lt; p){
         M[c*n+r] = X[c*n+r]-mu_j[j+c*g];
     }
 }
</pre></div><p><a class="anchor" id="Kernel__MM_scalar"></a> </p>
<h3>Kernel: __MM_scalar</h3>
<p>calculates the Matrix Matrix Scalarproduct by calculating the Scalarproduct of each row from the first matrix with it corresponding column from the second matrix</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __MM_scalar(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                             <span class="keyword">const</span> T * A,
                             <span class="keyword">const</span> T * B,
                             T * result)
 {
     <span class="keywordtype">int</span> r = blockIdx.x * blockDim.x + threadIdx.x;
 
     T sum = 0.;
 
     <span class="keywordflow">if</span>(r &lt; n){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j= 0; j&lt;p; j++){
             sum += A[j*n+r]*B[r*p+j];
         }
         result[r] = sum;
     }
 }
</pre></div><p><a class="anchor" id="Kernel__Det"></a> </p>
<h3>Kernel: __Det</h3>
<p>calculate the determinate</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __Det(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> MS,
                       <span class="keyword">const</span> T * A,
                       T * result)
 {
     T det = 1.;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;p; i++){
         det *= A[i*MS+i];
     }
 
     *result = det;
 
 }
</pre></div><p><a class="anchor" id="Kernel__P_ij"></a> </p>
<h3>Kernel: __P_ij</h3>
<p>calculates the <code>P_ij</code> matrix by solving the follwing equation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} P_{ij} = \frac{\gamma}{\Delta_j}\frac{1}{(1+\frac{\delta_{ij}}{\nu})^{(\nu+p)/2}}\end{equation}" src="form_131.png"/>
</p>
<p> and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \gamma = \frac{\Gamma(\frac{\nu+p}{2})}{\Gamma(\frac{\nu}{2})(\pi\nu)^{p/2}}\end{equation}" src="form_132.png"/>
</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __P_ij(T gamma,
                        T v,
                        <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * Delta,
                        <span class="keyword">const</span> T * delta,
                        T * P_ij)
 {
     <span class="keywordtype">int</span> i = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         P_ij[j*n+i] = gamma/Delta[j]/(pow((1.+delta[j*n+i]/v),(v+p)/2.));
     }
 
 
 }
</pre></div><p><a class="anchor" id="Kernel__u_ij"></a> </p>
<h3>Kernel: __u_ij</h3>
<p>calculates the <code>u_ij</code> matrix by solving the following equation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} u_{ij} = \frac{p+2}{\delta_{ij}+\nu}\end{equation}" src="form_133.png"/>
</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __u_ij(T v,
                        <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * delta,
                        T * u_ij)
 {
     <span class="keywordtype">int</span> i = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         u_ij[j*n+i] = (p+2)/(delta[j*n+i]+v);
     }
 
 }
</pre></div><p><a class="anchor" id="Kernel__z_ij"></a> </p>
<h3>Kernel: __z_ij</h3>
<p>calculates the <code>z_ij</code> matrix by solving the following equation: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} u_{ij} = \frac{P_{ij}\pi_j}{c}\end{equation}" src="form_134.png"/>
</p>
<p> and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} c = \sum_{l=1}^{g}P_{il}\pi_l\end{equation}" src="form_135.png"/>
</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __z_ij(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * P_ij,
                        <span class="keyword">const</span> T * c,
                        <span class="keyword">const</span> T * pi,
                        T * z_ij)
 {
     __shared__ T cs[512];
     __shared__ T pi_s[32];
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
     <span class="keywordtype">int</span> j = threadIdx.y;
 
 
     <span class="keywordflow">if</span> (j == 0){
         cs[threadIdx.x] = c[i];
     }
</pre></div><p>using the threadIdx.x to load data into the sharedmemory because it runs faster than threadIdx.y</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span>(threadIdx.x &lt; g &amp;&amp; j == 0){
         pi_s[threadIdx.x] = pi[threadIdx.x];
     }
 
     __syncthreads();
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         z_ij[j*n+i] = (P_ij[j*n+i]*pi_s[j])/cs[threadIdx.x];
     }
 
 }
</pre></div><p><a class="anchor" id="Functionreduction"></a> </p>
<h4>Function: reduction</h4>
<p>performs the last reduction on the sharedmemory <br/>
 if thread_block isn't fill_fledged, it could cause some problems</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 __device__ <span class="keywordtype">void</span> reduction(<span class="keyword">volatile</span> T * sum, <span class="keywordtype">int</span> tid)
 {
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = blockDim.x/2; k&gt;0; k/=2){
         <span class="keywordflow">if</span>(tid &lt; k){
             sum[tid] += sum[tid + k];
         }
         __syncthreads();
     }
 }
</pre></div><p><a class="anchor" id="Kernel__sum_array"></a> </p>
<h3>Kernel: __sum_array</h3>
<p>sums up the entries of the input array in <code>result</code> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __sum_array(<span class="keywordtype">int</span> n,
                             <span class="keyword">const</span> T * input,
                             T * result)
 {
     __shared__ T sum[512];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     sum[threadIdx.x] += input[i];
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         result[blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p><a class="anchor" id="Kernel__sum_log_array"></a> </p>
<h3>Kernel: __sum_log_array</h3>
<p>sums up the logarithm of the entries of the input array in <code>result</code> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __sum_log_array(<span class="keywordtype">int</span> n,
                                 <span class="keyword">const</span> T * input,
                                 T * result)
 {
     __shared__ T sum[512];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     sum[threadIdx.x] += log(input[i]);
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         result[blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p><a class="anchor" id="Kernel__sum_array2D"></a> </p>
<h3>Kernel: __sum_array2D</h3>
<p>calculates the row sum of the multiplication of <code>z_ij</code> with <code>u_ij</code> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __sum_array2D(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                               <span class="keyword">const</span> T * z_ij,
                               <span class="keyword">const</span> T * u_ij,
                               T * output)
 {
     __shared__ T sum[512];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.y;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     <span class="keywordtype">int</span> global_index = j*n+i;
     sum[threadIdx.x] += z_ij[global_index]* u_ij[global_index];
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         output[blockIdx.y*gridDim.x+blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p><a class="anchor" id="Kernel__y"></a> </p>
<h3>Kernel: __y</h3>
<p>calculates y with: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} y = \sum_{i=1}^{n}\sum_{j=1}^{g}z_{ij}[\psi+log(\frac{2}{\delta_{ij}+\nu_{old}})-u_{ij}]\end{equation}" src="form_136.png"/>
</p>
<p> and </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \psi = \psi(\frac{p+\nu{old}}{2}) \end{equation}" src="form_137.png"/>
</p>
<p> with <img class="formulaInl" alt="$\psi$" src="form_138.png"/> = the digamma function.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __y(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g, T v, T digamma,
                     <span class="keyword">const</span> T * z_ij,
                     <span class="keyword">const</span> T * delta_ij,
                     <span class="keyword">const</span> T * u_ij,
                     T * results)
 {
     __shared__ T sum[256];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         <span class="keywordtype">int</span> global_index = j*n+i;
         sum[threadIdx.x] += z_ij[global_index]*(digamma+log(2/(delta_ij[global_index]+v))-u_ij[global_index]);
     }
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         results[blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p><a class="anchor" id="Kernel__MxM"></a> </p>
<h3>Kernel: __MxM</h3>
<p>calculates the prduct of each entry of the first matrix with the corresponding one inn the second matrix. the results are saved in the new matrix <code>q_ij</code>.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __MxM(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                       <span class="keyword">const</span> T * z_ij,
                       <span class="keyword">const</span> T * u_ij,
                       T * q_ij)
 {
     <span class="keywordtype">int</span> i = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         q_ij[j*n+i] = z_ij[j*n+i]*u_ij[j*n+i];
     }
 }
</pre></div><p><a class="anchor" id="Kernel__SMX"></a> </p>
<h3>Kernel: __SMX</h3>
<p>calculates the following: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} M = \sum_{i=1}^{n}\sqrt{\frac{q_{ij}}{C_j}}(\vec{x_i}-\vec{\mu_j})\end{equation}" src="form_139.png"/>
</p>
<p> with </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} q_{ij} = z_{ij}u_{ij} \end{equation}" src="form_140.png"/>
</p>
<p> and <code>C_j</code> = the j_th array from the matrix C which is </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} C = \sum_{i=1}^{n}z_{ij}u_{ij}\end{equation}" src="form_141.png"/>
</p>
<p> therefore by calculating <img class="formulaInl" alt="$M^T * M$" src="form_142.png"/> we get </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \Sigma_j = \sum_{i=1}^{n}\frac{\left(z_{ij}u_{ij}\right)(\vec{x_i}-\vec{\mu_j})(\vec{x_i}-\vec{\mu_j})^T}{\sum_{i=1}^{n}z_{ij}u_{ij}}\end{equation}" src="form_143.png"/>
</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __SMX(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                       <span class="keyword">const</span> T * q_ij,
                       <span class="keyword">const</span> T inv_C_j,
                       <span class="keyword">const</span> <span class="keywordtype">int</span> j,
                       <span class="keyword">const</span> T * X,
                       <span class="keyword">const</span> T * mu_j,
                       T * M)
 {
     <span class="keywordtype">int</span> r = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> c = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(r &lt; n &amp;&amp; c &lt; p){
         M[c*n+r] = (X[c*n+r]-mu_j[c]) * sqrt(q_ij[j*n+r] * inv_C_j);
     }
 }
</pre></div><p><a class="anchor" id="Functionsubtract_array_from_matrix"></a> </p>
<h4>Function:subtract_array_from_matrix</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows in the input Matrix <code>X</code> (represents the number of datapoints). </td></tr>
    <tr><td class="paramname">p</td><td>: number of rows (represents the space dimension). </td></tr>
    <tr><td class="paramname">j</td><td>: index of the array <code>mu_j</code>. </td></tr>
    <tr><td class="paramname">g</td><td>: number of rows in the array <code>mu_j</code> (represents the number of cluster centers). </td></tr>
    <tr><td class="paramname">X</td><td>: input matrix with <code>n</code> rows and <code>p</code> columns. </td></tr>
    <tr><td class="paramname">mu_j</td><td>: the array which is subtracted from the matrix <code>X</code> . </td></tr>
    <tr><td class="paramname">M</td><td>: output result matrix.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> Kernel&lt;T&gt;::subtract_array_from_matrix(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> g,
                                            <span class="keyword">const</span> T * X,
                                            <span class="keyword">const</span> T * mu_j,
                                            T * M)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(p, gridDim_y);
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 1;
     <span class="keywordtype">int</span> n_memory_access = 3;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     dt &lt;&lt;<span class="stringliteral">&quot;Kernel name&quot;</span>
       &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
      &lt;&lt;<span class="stringliteral">&quot;Time in Milliseconds&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;\t\t&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;bandwidth in GB/s&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;\t\t&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;Gflops/Second&quot;</span>
     &lt;&lt; std::endl;
     dt &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------------------------------------------------------------------&quot;</span>
        &lt;&lt;std::endl;
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s &lt; N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __subtract_array_from_matrix&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, p, j, g,
                                                                  X,
                                                                  mu_j,
                                                                  M);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;subtract_kernel:::::&quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/ Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p><a class="anchor" id="FunctionMM_scalar"></a> </p>
<h4>Function: MM_scalar</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows in the input matrices. </td></tr>
    <tr><td class="paramname">p</td><td>: number of columns in the input matrices (represents the space dimension). </td></tr>
    <tr><td class="paramname">A</td><td>: first input matrix of the size <code>n</code> X <code>p</code>. </td></tr>
    <tr><td class="paramname">B</td><td>: second input matrix. </td></tr>
    <tr><td class="paramname">output</td><td>: result vector.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> Kernel&lt;T&gt;::MM_scalar(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                           <span class="keyword">const</span> T * A,
                           <span class="keyword">const</span> T * B,
                           T * output)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">long</span> n_operations = 2*p;
     <span class="keywordtype">int</span> n_memory_access = 2*p+1;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
         __MM_scalar&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, p,
                                                 A,
                                                 B,
                                                 output);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;MM_scalar:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*p)*n_operations)/(time_sum/1000)/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 }
</pre></div><p><a class="anchor" id="FunctionDet"></a> </p>
<h4>Function: Det</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>: size of the matrixview <code>A</code> . </td></tr>
    <tr><td class="paramname">MS</td><td>: The size of the original matrix where <code>A</code> is stored. </td></tr>
    <tr><td class="paramname">A</td><td>: input matrixview on the original matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>det : returns the determinant of the matrix <code>A</code> .</dd></dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 T
 Kernel&lt;T&gt;::Det(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> MS, <span class="keyword">const</span> T * A)
 {
     <span class="keywordtype">int</span> block_size = 1;
     <span class="keywordtype">int</span> num_blocks = 1;
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = p;
     <span class="keywordtype">int</span> n_memory_access = p+1;
 
 
     T det;
     T * det_d;
     cudaMalloc(&amp;det_d, <span class="keyword">sizeof</span>(T));
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __Det&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(p, MS, A, det_d);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;Det_Kernel:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((p*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((p*p*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(&amp;det, det_d,
                <span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     cudaFree(det_d);
 
     <span class="keywordflow">return</span> det;
 }
</pre></div><p><a class="anchor" id="Functionassemble_P_ij"></a> </p>
<h4>Function: assemble_P_ij</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>: value of gamma calculated on the CPU. </td></tr>
    <tr><td class="paramname">v</td><td>: DOF parameter. </td></tr>
    <tr><td class="paramname">p</td><td>: number of columns. </td></tr>
    <tr><td class="paramname">n</td><td>: number of rows. </td></tr>
    <tr><td class="paramname">g</td><td>: number of cluster centers. </td></tr>
    <tr><td class="paramname">Delta</td><td>: input <img class="formulaInl" alt="$Delta_j$" src="form_144.png"/> array. </td></tr>
    <tr><td class="paramname">delta</td><td>: input <img class="formulaInl" alt="$delta_{ij}$" src="form_145.png"/> matrix containing the Mahalanobis squared distance betweet each datapoint the the real cluster centers. </td></tr>
    <tr><td class="paramname">P_ij</td><td>: result matrix.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::assemble_P_ij(T gamma,
                          T v,
                          <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * Delta,
                          <span class="keyword">const</span> T * delta,
                          T * P_ij)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(g, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 4;
     <span class="keywordtype">int</span> n_memory_access = 3;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
 
         __P_ij&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(gamma,
                                            v,
                                            p, n, g,
                                            Delta,
                                            delta,
                                            P_ij);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;assemble_P_ij:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p><a class="anchor" id="Functionassemble_u_ij"></a> </p>
<h4>Function: assemble_u_ij</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>: DOF parameter. </td></tr>
    <tr><td class="paramname">p</td><td>: number of columns. </td></tr>
    <tr><td class="paramname">n</td><td>: number of rows. </td></tr>
    <tr><td class="paramname">g</td><td>: number of cluster centers. </td></tr>
    <tr><td class="paramname">delta</td><td>: input Mahalanobis squared distances matrix <img class="formulaInl" alt="$\delta_{ij}$" src="form_107.png"/>. </td></tr>
    <tr><td class="paramname">u_ij</td><td>: output weights matrix.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::assemble_u_ij(T v,
                          <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * delta,
                          T * u_ij)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(g, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 2;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __u_ij&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(v,
                                            p, n, g,
                                            delta,
                                            u_ij);
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;assemble_u_ij:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p><a class="anchor" id="Functionassemble_z_ij"></a> </p>
<h4>Function: assemble_z_ij</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows in the <code>P_ij</code> matrix and c array </td></tr>
    <tr><td class="paramname">g</td><td>: number of cluster centers (in this case the number of rows in the <img class="formulaInl" alt="$\pi$" src="form_98.png"/> array </td></tr>
    <tr><td class="paramname">P_ij</td><td>: input matrix representing the distribution of the jth spike. </td></tr>
    <tr><td class="paramname">c</td><td>: c array. </td></tr>
    <tr><td class="paramname">pi</td><td>: proportion array <img class="formulaInl" alt="$\pi$" src="form_98.png"/> </td></tr>
    <tr><td class="paramname">z_ij</td><td>: output memberships matrix.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::assemble_z_ij(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * P_ij,
                          <span class="keyword">const</span> T * c,
                          <span class="keyword">const</span> T * pi,
                          T * z_ij)
 {
     <span class="keywordtype">int</span> blockDim_x = max(16/g, 1) * 32;
     dim3 block_size(blockDim_x,g);
     <span class="keywordtype">int</span> num_blocks = (n+blockDim_x-1)/blockDim_x;
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 2;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
         __z_ij&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, g,
                                            P_ij,
                                            c,
                                            pi,
                                            z_ij);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;assemble_z_ij:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; ((((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)+n+g)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p><a class="anchor" id="Functioncalculate_y"></a> </p>
<h4>Function: calculate_y</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows (number of datapoints). </td></tr>
    <tr><td class="paramname">g</td><td>: number of columns (in this case the number of cluster centers). </td></tr>
    <tr><td class="paramname">v</td><td>: DOF parameter. </td></tr>
    <tr><td class="paramname">digamma</td><td>: the digamma function calculated in the CPU. </td></tr>
    <tr><td class="paramname">z_ij</td><td>: input memberships matrix. </td></tr>
    <tr><td class="paramname">delta_ij</td><td>: input Mahalanobis squared distances matrix. </td></tr>
    <tr><td class="paramname">u_ij</td><td>: input weight matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>y : the value y.</dd></dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">double</span>
 Kernel&lt;T&gt;::calculate_y(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g, T v, T digamma,
                        <span class="keyword">const</span> T * z_ij,
                        <span class="keyword">const</span> T * delta_ij,
                        <span class="keyword">const</span> T * u_ij)
 {
     <span class="keywordtype">int</span> block_size = 256;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
     T y;
 
     T * results_h = <span class="keyword">new</span> T[num_blocks];
     T * results_d;
     cudaMalloc(&amp;results_d, num_blocks*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 6*g + sqrt(block_size/2)+1;
     <span class="keywordtype">int</span> n_memory_access = 4;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __y&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, g, v, digamma,
                                         z_ij,
                                         delta_ij,
                                         u_ij,
                                         results_d);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;calculate_y:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                num_blocks*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_blocks; i++){
         y += results_h[i];
     }
 
     <span class="keywordflow">return</span> y;
 }
</pre></div><p><a class="anchor" id="Functionsum_array"></a> </p>
<h4>Function: sum_array</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of elements in the input array. </td></tr>
    <tr><td class="paramname">input</td><td>: input array with <code>n</code> entries. </td></tr>
    <tr><td class="paramname">log</td><td>: determin summing up the entries or the logarithm of the entries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result : the sum of the input entries.</dd></dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">double</span>
 Kernel&lt;T&gt;::sum_array(<span class="keywordtype">int</span> n,
                      <span class="keyword">const</span> T * input,
                      <span class="keywordtype">bool</span> log)
 {
     <span class="keywordtype">double</span> result = 0.;
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
 
     T * results_h = <span class="keyword">new</span> T[num_blocks];
     T * results_d;
     cudaMalloc(&amp;results_d, num_blocks*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = sqrt(block_size/2)+1+1;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         <span class="keywordflow">if</span>(log){
             __sum_log_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input,results_d);
         }<span class="keywordflow">else</span>{
             __sum_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input,results_d);
         }
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;sum_array:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                num_blocks*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
</pre></div><p>sums up the results of each block to one value</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_blocks; i++){
         result += results_h[i];
     }
 
     <span class="keywordflow">return</span> result;
 }
</pre></div><p><a class="anchor" id="Functionsum_matrix_cols"></a> </p>
<h4>Function: sum_matrix_cols</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows. </td></tr>
    <tr><td class="paramname">g</td><td>: number of cluster centers (columns). </td></tr>
    <tr><td class="paramname">input</td><td>: input matrix with n rows and g columns. </td></tr>
    <tr><td class="paramname">output</td><td>: output array containing the results of the sum of each matrix column. </td></tr>
    <tr><td class="paramname">log</td><td>: determin summing up the logarithm of the matrix entries or not.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::sum_matrix_cols(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                            <span class="keyword">const</span> T * input,
                            T * output,
                            <span class="keywordtype">bool</span> log)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
 
     T * results_h = <span class="keyword">new</span> T[num_blocks*g];
     T * results_d;
     cudaMalloc(&amp;results_d, num_blocks*g*<span class="keyword">sizeof</span>(T));
</pre></div><p>the Kernel is called g times for each row of the matrix</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0;j &lt; g; j++){
         <span class="keywordflow">if</span>(log){
             __sum_log_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input+(n*j),results_d+(j*num_blocks));
         }<span class="keywordflow">else</span>{
             __sum_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input+(n*j),results_d+(j*num_blocks));
         }
     }
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                num_blocks*g*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
</pre></div><p>for each cluster center sums up the results of each block to one value.</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_blocks; i++){
             output[j] += results_h[i+j*num_blocks];
         }
     }
 
 }
</pre></div><p><a class="anchor" id="Functionsum_array2D"></a> </p>
<h4>Function: sum_array2D</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows. </td></tr>
    <tr><td class="paramname">g</td><td>: number of columns. </td></tr>
    <tr><td class="paramname">z_ij</td><td>: input memberships matrix. </td></tr>
    <tr><td class="paramname">u_ij</td><td>: input weights matrix. </td></tr>
    <tr><td class="paramname">output</td><td>: output array withthe sum of each column in each entry.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::sum_array2D(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * z_ij,
                        <span class="keyword">const</span> T * u_ij,
                        T * output)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_x = ((n+block_size-1)/block_size);
     dim3 num_blocks (gridDim_x, g);
 
 
     T * results_h = <span class="keyword">new</span> T[gridDim_x*g];
     T * results_d;
     cudaMalloc(&amp;results_d, gridDim_x*g*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 2 + sqrt(block_size/2)+1;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __sum_array2D&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,g,z_ij, u_ij,results_d);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;sum_array2D:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                gridDim_x*g*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;g; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j= 0; j&lt;gridDim_x; j++){
             output[i] += results_h[i*gridDim_x+j];
         }
     }
 
 }
</pre></div><p><a class="anchor" id="FunctionMxM"></a> </p>
<h4>Function: MxM</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows. </td></tr>
    <tr><td class="paramname">g</td><td>: number of columns. </td></tr>
    <tr><td class="paramname">z_ij</td><td>: first input matrix. </td></tr>
    <tr><td class="paramname">u_ij</td><td>: second input matrix. </td></tr>
    <tr><td class="paramname">q_ij</td><td>: output results matrix.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::MxM(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                <span class="keyword">const</span> T * z_ij,
                <span class="keyword">const</span> T * u_ij,
                T * q_ij)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(g, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 1;
     <span class="keywordtype">int</span> n_memory_access = 3;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __MxM&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, g,
                                           z_ij,
                                           u_ij,
                                           q_ij);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;MxM_Kernel:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p><a class="anchor" id="FunctionSMX"></a> </p>
<h4>Function: SMX</h4>
<p>Wrapper-Function for the Kernel. Sets the threads distribution and runs them. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>: number of rows. </td></tr>
    <tr><td class="paramname">p</td><td>: number of entries in the u_j array. </td></tr>
    <tr><td class="paramname">q_ij</td><td>: matrix <img class="formulaInl" alt="$q_{ij}$" src="form_146.png"/> wich results from <img class="formulaInl" alt="$z_{ij}*u_{ij}$" src="form_147.png"/>. </td></tr>
    <tr><td class="paramname">C_j</td><td>: the sum of rows of <img class="formulaInl" alt="$z_{ij}*u_{ij}$" src="form_147.png"/>. </td></tr>
    <tr><td class="paramname">X</td><td>: the datapoints matrix. </td></tr>
    <tr><td class="paramname">mu_j</td><td>: the j_th cluster center. </td></tr>
    <tr><td class="paramname">M</td><td>: result matrix <code>M</code>.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::SMX(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                <span class="keyword">const</span> T * q_ij,
                <span class="keyword">const</span> T C_j,
                <span class="keyword">const</span> <span class="keywordtype">int</span> j,
                <span class="keyword">const</span> T * X,
                <span class="keyword">const</span> T * mu_j,
                T * M)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(p, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 4;
     <span class="keywordtype">int</span> n_memory_access = 5;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
</pre></div><p>printf("Kernel Running ");</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __SMX&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, p,
                                           q_ij,
                                           T(1./C_j),
                                           j,
                                           X,
                                           mu_j,
                                           M);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
</pre></div><p>if((s%10) == 0) printf(". ");</p>
<div class="fragment"><pre class="fragment">     }
</pre></div><p>printf("\n");</p>
<div class="fragment"><pre class="fragment">     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;SMX_Kernel:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*p*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p>This has to be at the end of file, because all functions have to be declared and their bodies defined before the class can be explictly instantiated by the compiler.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> <span class="keyword">class </span>Kernel&lt;float&gt;;
 
<span class="preprocessor"> #ifndef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span> <span class="keyword">template</span> <span class="keyword">class </span>Kernel&lt;double&gt;;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef CUDADriver_STEP_7_H</span>
<span class="preprocessor"></span><span class="preprocessor"> #define CUDADriver_STEP_7_H</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #include &lt;deal.II/base/parameter_handler.h&gt;</span>
 
<span class="preprocessor"> #include &lt;lac/blas++.h&gt;</span>
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;step-6/cuda_driver_step-6.h&gt;</span>
<span class="preprocessor"> #include &lt;step-6/cuda_driver_step-6.hh&gt;</span>
<span class="preprocessor"> #include &lt;step-6/Kmeans.h&gt;</span>
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #include &lt;step-7/cuda_kernel_wrapper_step-7.cu.h&gt;</span>
 
 <span class="keyword">namespace </span>step7 {
</pre></div><p><a class="anchor" id="ClassShohamEM"></a> </p>
<h3>Class: ShohamEM</h3>
<p>declares the variables and methods needed for the Shoham EM algorithm</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">class </span>ShohamEM : <span class="keyword">public</span> Kernel&lt;T&gt; {
 <span class="keyword">public</span>:
 <span class="keyword">public</span>:
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::blas_wrapper_type  BW;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix             Matrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix          SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol       MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubRow       MatrixSubRow;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubColVector SubColVector;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubRowVector SubRowVector;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector             Vector;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;                    tr;
     <span class="keyword">typedef</span>          transpose&lt;SubMatrix&gt;                 trSub;
</pre></div><p>--- algorithm data</p>
<div class="fragment"><pre class="fragment">     Matrix mu;
     <span class="keywordtype">int</span> g;
     <span class="keywordtype">int</span> g_min;
     std::vector&lt;T&gt; pi;
     std::vector&lt;Matrix&gt; Sigma;
     T v;
     <span class="keywordtype">double</span> L;
     <span class="keywordtype">double</span> L_max;
     <span class="keywordtype">double</span> N;
     <span class="keywordtype">int</span> p;
     Matrix u_ij;
     Matrix z_ij;
     Matrix P_ij;
 
     Matrix data;
     Matrix mean;
     <span class="keywordtype">int</span> n_data_points;
     Matrix delta_ij;
     std::vector&lt;Matrix&gt; Sigma_inv;
     T gamma;
     Vector Delta;
     std::vector&lt;Matrix&gt; Sigma_dec;
     Vector pi_d;
     Matrix M;
     <span class="keywordtype">int</span> iter;
</pre></div><p>---</p>
<div class="fragment"><pre class="fragment">     std::vector&lt;T&gt; pi_opt;
     Matrix mu_opt;
     std::vector&lt;Matrix&gt; Sigma_opt;
     T v_opt;
     Matrix u_ij_opt;
     Matrix z_ij_opt;
     Matrix P_ij_opt;
 
     <span class="keywordtype">int</span> it;
 
     ShohamEM(FullMatrixAccessor &amp;ddata, FullMatrixAccessor &amp;mmeans);
 
     <span class="keywordtype">void</span> dump();
 
     <span class="keywordtype">void</span> run_Shoham();
     <span class="keywordtype">void</span> initialize_Shoham();
     <span class="keywordtype">void</span> e_step_Shoham();
     <span class="keywordtype">void</span> m_step_Shoham();
     <span class="keywordtype">void</span> purge_step_Shoham();
 
     ~ShohamEM();
 
 };
</pre></div><p><a class="anchor" id="ClassKernelTest"></a> </p>
<h3>Class: KernelTest</h3>
<p>declares the variables and methods needed for the Kernel Tests</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">class </span>KernelTest : <span class="keyword">public</span> Kernel&lt;T&gt; {
 <span class="keyword">public</span>:
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::blas_wrapper_type  BW;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix             Matrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix          SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol       MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubRow       MatrixSubRow;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector             Vector;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;              tr;
     <span class="keyword">typedef</span>          transpose&lt;SubMatrix&gt;              trSub;
 
 
     KernelTest(<span class="keywordtype">int</span> n_data_points, <span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> n_clusters);
 
     <span class="keywordtype">int</span> n_data_points, n_clusters, dim;
 
     <span class="keywordtype">void</span> run();
 
     ~KernelTest();
 };
 
 } <span class="comment">// namespace step7 END</span>
 
<span class="preprocessor"> #endif // CUDADriver_STEP_7_H</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef CUDA_DRIVER_STEP_7_HH</span>
<span class="preprocessor"></span><span class="preprocessor"> #define CUDA_DRIVER_STEP_7_HH</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;cuda_driver_step-7.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_kernel_wrapper_step-7.cu.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_kernel_wrapper_step-1.cu.h&gt;</span>
 
<span class="preprocessor"> #include &lt;base/CUDATimer.h&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/base/timer.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cmath&gt;</span>
<span class="preprocessor"> #include &lt;limits&gt;</span>
 
<span class="preprocessor"> #include &lt;lac/cublas_wrapper.hh&gt;</span>
 
<span class="preprocessor"> #include &lt;boost/math/special_functions/digamma.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/math/special_functions/erf.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/math/special_functions/beta.hpp&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/numerics/histogram.h&gt;</span>
 
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
 
<span class="preprocessor"> #include &lt;QTime&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/base/convergence_table.h&gt;</span>
<span class="preprocessor"> #include &lt;deal.II/base/table_handler.h&gt;</span>
<span class="preprocessor"> #include &lt;deal.II/base/timer.h&gt;</span>
 
<span class="preprocessor"> #include &lt;fstream&gt;</span>
</pre></div><p><a class="anchor" id="StructRightMSolve"></a> </p>
<h3>Struct: RightMSolve</h3>
<p>Solves the equation ?X : AX = B A,X,B Matrices</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">struct </span>RightMSolve{
 
     <span class="keyword">typedef</span> bw_types::SubMatrixView&lt;T, blas&gt; SubMatrix;
 
     <span class="keyword">const</span> SubMatrix &amp;l;
     SubMatrix &amp;r;
 
     RightMSolve(<span class="keyword">const</span> SubMatrix &amp; _l, SubMatrix &amp; _r):l(_l),r(_r){}
</pre></div><p><a class="anchor" id="Operator"></a> </p>
<h4>Operator: = </h4>
<p>overwrite the operator = for Matrix-Matrix Multiplication</p>
<div class="fragment"><pre class="fragment">     RightMSolve&lt;T, blas&gt; &amp; operator = (<span class="keyword">const</span> SubMatrix &amp; rhs)
</pre></div><p>Argumens are consistance with the cublas Documentation</p>
<div class="fragment"><pre class="fragment">     {
</pre></div><p>copy the rightside to the resultsmatrix,so cublas will be able to overwrite the memory area containing the rightside with the solution.</p>
<div class="fragment"><pre class="fragment">         r = rhs.matrix();
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;? X : AX = B &quot;</span> &lt;&lt; std::endl;
         <span class="keywordtype">char</span> side = <span class="charliteral">&#39;L&#39;</span>, uplo = <span class="charliteral">&#39;U&#39;</span>, transa = <span class="charliteral">&#39;N&#39;</span>, diag = <span class="charliteral">&#39;N&#39;</span>;
         <span class="keywordtype">int</span> m = rhs.r_end() - rhs.r_begin();
         <span class="keywordtype">int</span> n = rhs.c_end() - rhs.c_begin();
 
         T alpha = 1.0;
 
         <span class="keyword">const</span> T * <span class="keyword">const</span> A = l.val();
         <span class="keywordtype">int</span> lda = l.leading_dim();
 
         T *  B = r.val();
         <span class="keywordtype">int</span> ldb = r.leading_dim();
         blas::trsm(  side, uplo, transa, diag,
                      m, n, alpha,
                      A, lda, B, ldb     );
 
         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
     }
 
 };
</pre></div><p><a class="anchor" id="StructRightMSolveTr"></a> </p>
<h3>Struct: RightMSolveTr</h3>
<p>Solves the equation for <img class="formulaInl" alt="$X$" src="form_148.png"/>: <img class="formulaInl" alt="$A^TX = B$" src="form_149.png"/> where <img class="formulaInl" alt="$A, X, B$" src="form_150.png"/> are matrixes</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">struct </span>RightMSolveTr{
 
     <span class="keyword">typedef</span> bw_types::SubMatrixView&lt;T, blas&gt; SubMatrix;
     <span class="keyword">typedef</span>          transpose&lt;SubMatrix&gt;           tr;
 
     <span class="keyword">const</span> SubMatrix &amp;l;
     SubMatrix &amp;r;
 
     RightMSolveTr(<span class="keyword">const</span> tr &amp; _l, SubMatrix &amp; _r):l(_l.A),r(_r){}
</pre></div><p><a class="anchor" id="Operator"></a> </p>
<h4>Operator: = </h4>
<p>overwrite the operator = for Matrix-Matrix Multiplication</p>
<div class="fragment"><pre class="fragment">     RightMSolveTr&lt;T, blas&gt; &amp; operator = (<span class="keyword">const</span> SubMatrix &amp; rhs)
</pre></div><p>Argumens are consistance with the cublas Documentation</p>
<div class="fragment"><pre class="fragment">     {
</pre></div><p>copy the rightside to the resultsmatrix,so cublas will be able to overwrite the memory area containing the rightside with the solution.</p>
<div class="fragment"><pre class="fragment">         r = rhs.matrix();
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;? X : A^TX = B &quot;</span> &lt;&lt; std::endl;
         <span class="keywordtype">char</span> side = <span class="charliteral">&#39;L&#39;</span>, uplo = <span class="charliteral">&#39;U&#39;</span>, transa = <span class="charliteral">&#39;T&#39;</span>, diag = <span class="charliteral">&#39;N&#39;</span>;
         <span class="keywordtype">int</span> m = rhs.r_end() - rhs.r_begin();
         <span class="keywordtype">int</span> n = rhs.c_end() - rhs.c_begin();
 
         T alpha = 1.0;
 
         <span class="keyword">const</span> T * <span class="keyword">const</span> A = l.val();
         <span class="keywordtype">int</span> lda = l.leading_dim();
 
         T * B = r.val();
         <span class="keywordtype">int</span> ldb = r.leading_dim();
         cublas::trsm(  side, uplo, transa, diag,
                        m, n, alpha,
                        A, lda, B, ldb     );
 
         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
     }
 
 };
</pre></div><p><a class="anchor" id="Operator"></a> </p>
<h4>Operator: *</h4>
<p>Overwrite the Operators * for Matrix-Matrix Multiplication</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">inline</span> RightMSolve&lt;T, blas&gt;  operator * (<span class="keyword">const</span> bw_types::SubMatrixView&lt;T, blas&gt; &amp;l, bw_types::SubMatrixView&lt;T, blas&gt; &amp; r){
     <span class="keywordflow">return</span> RightMSolve&lt;T, blas&gt;(l,r);
 }
</pre></div><p><a class="anchor" id="Operator"></a> </p>
<h4>Operator: *</h4>
<p>Overwrite the Operators * for Matrix-Matrix Multiplication</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">inline</span> RightMSolveTr&lt;T, blas&gt;  operator * (<span class="keyword">const</span> <span class="keyword">typename</span> RightMSolveTr&lt;T, blas&gt;::tr  &amp;l,
                                            bw_types::SubMatrixView&lt;T, blas&gt; &amp; r){
     <span class="keywordflow">return</span> RightMSolveTr&lt;T, blas&gt;(l,r);
 }
</pre></div><p><a class="anchor" id="ConstructorShohamEM"></a> </p>
<h4>Constructor: ShohamEM</h4>
<p>Creates an instance of the ShohamEm algorithm and initilize the data and mean matrices. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ddata</td><td>: matrix containing the datapoints. </td></tr>
    <tr><td class="paramname">mmeans</td><td>: matrix containing the starting means.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::ShohamEM&lt;T, blas&gt;::ShohamEM(FullMatrixAccessor &amp;ddata, FullMatrixAccessor &amp;mmeans)
     :
       n_data_points(ddata.n_rows()), p(ddata.n_cols()),
       g(mmeans.n_rows()), data(ddata.n_rows(), ddata.n_cols())
 {
     BW::Init();
     data = ddata;
     mean = mmeans;
 }
</pre></div><p><a class="anchor" id="Functiondump"></a> </p>
<h4>Function: dump</h4>
<p>current data dump</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T,blas&gt;::dump()
 {
</pre></div><p>---- save em means</p>
<div class="fragment"><pre class="fragment">     std::fstream em;
     em.open(<span class="stringliteral">&quot;output/em.dat&quot;</span>, std::ios::out);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; mu.n_rows(); i++){
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; mu.n_cols(); j++)
             em &lt;&lt; mu(i, j) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
 
         em &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
     }
 
     em.close();
</pre></div><p>save Pi</p>
<div class="fragment"><pre class="fragment">     std::fstream piout;
     piout.open(<span class="stringliteral">&quot;output/pi.dat&quot;</span>, std::ios::out);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pi.size(); i++)
         piout &lt;&lt; pi[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
     piout.close();
</pre></div><p>calculate ellipse parameters for each class</p>
<div class="fragment"><pre class="fragment">     std::fstream ellipse;
     ellipse.open(<span class="stringliteral">&quot;output/ellipses.dat&quot;</span>, std::ios::out);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; g; k++){
 
         <span class="keywordtype">double</span> d;
         <span class="keywordtype">double</span> eig[2], eigv[2];
         <span class="keywordtype">int</span> perm[2];
 
         d = (Sigma[k](0, 0) - Sigma[k](1, 1)) / 2;
 
         eig[0] = (Sigma[k](0, 0) + Sigma[k](1, 1)) / 2 + sqrt(d * d + Sigma[k](0, 1) * Sigma[k](1, 0));
         eig[1] = (Sigma[k](0, 0) + Sigma[k](1, 1)) / 2 - sqrt(d * d + Sigma[k](0, 1) * Sigma[k](1, 0));
 
         <span class="keywordflow">if</span>(eig[0] &gt; eig[1] || <span class="keyword">true</span>){
             perm[0] = 0;
             perm[1] = 1;
         }
         <span class="keywordflow">else</span>{
             perm[0] = 1;
             perm[1] = 0;
         }
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;\nEig: &quot;</span> &lt;&lt; eig[perm[0]] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
         eigv[0] = eig[perm[0]] - Sigma[k](1, 1);
         eigv[1] = Sigma[k](1, 0);
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;Eigv: &quot;</span> &lt;&lt; eigv[0] / sqrt(eigv[0] * eigv[0] + eigv[1] * eigv[1]) &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; perm[0] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
         ellipse &lt;&lt; mu(k, 0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; mu(k, 1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; / *sqrt(* /sqrt(sqrt(eig[perm[0]]))/ *)* / &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sqrt(sqrt(sqrt(eig[perm[1]])))
                 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;  acos(eigv[0] / sqrt(eigv[0] * eigv[0] + eigv[1] * eigv[1])) * 180 / M_PI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
     }
 
     ellipse.close();
</pre></div><p>assemble and execute gnuplot script</p>
<div class="fragment"><pre class="fragment">     QString plot_waves, plot_pca, plot_ellipses, plot_hist, plot_process;
 
     FILE *gp = popen(<span class="stringliteral">&quot;/usr/local/lib/FEM/gnuplot/bin/gnuplot&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);<span class="comment">//open a pipe to gnuplot</span>
 
     <span class="keywordflow">if</span>(iter == 0){
         plot_waves += <span class="stringliteral">&quot;!rm plot/ *\n&quot;</span>;
     }
 
     plot_waves += <span class="stringliteral">&quot;set terminal postscript landscape enhanced color solid linewidth 1.0 &#39;Helvetica&#39; 15\n&quot;</span>
             <span class="stringliteral">&quot;set output &#39;plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.ps&#39;\n&quot;</span>
             <span class="stringliteral">&quot;set multiplot\n&quot;</span>
             <span class="stringliteral">&quot;set xrange [0:128]\n&quot;</span>
             <span class="stringliteral">&quot;set yrange [-1.5:1.5]\n&quot;</span>
             <span class="stringliteral">&quot;set size 1,0.3\n&quot;</span>
             <span class="stringliteral">&quot;set origin 0,0.8\n&quot;</span>
             <span class="stringliteral">&quot;set key off\n&quot;</span>;
 
     plot_pca += <span class="stringliteral">&quot;reset\n&quot;</span>
             <span class="stringliteral">&quot;set key off\n&quot;</span>
             <span class="stringliteral">&quot;set size 1,0.7\n&quot;</span>
             <span class="stringliteral">&quot;set origin 0,0.15\n&quot;</span>
             <span class="stringliteral">&quot;set style data points\n&quot;</span>
             <span class="stringliteral">&quot;set yrange []\n&quot;</span>
             <span class="stringliteral">&quot;set xrange []\n&quot;</span>;
 
     plot_hist = <span class="stringliteral">&quot;set origin 0,-0.1\n&quot;</span>
             <span class="stringliteral">&quot;set size 1,0.3\n&quot;</span>
             <span class="stringliteral">&quot;set boxwidth 0.8\n&quot;</span>
             <span class="stringliteral">&quot;set style fill solid\n&quot;</span>
             <span class="stringliteral">&quot;set yrange [0:0.3]\n&quot;</span>
             <span class="stringliteral">&quot;set xrange [-0.5:0.5]\n&quot;</span>;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt;= n_data_points; i+=1){
 
         <span class="keywordtype">int</span> max = 0;
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 1; j &lt; z_ij.n_cols(); j++)
             <span class="keywordflow">if</span>(z_ij(i-1, j) &gt; z_ij(i-1, max))
                 max = j;
 
         <span class="keywordtype">int</span> outlier = 1;
         <span class="keywordflow">if</span>(u_ij(i-1, max) &lt; 0.75) outlier = 4;
         <span class="keywordflow">if</span>(u_ij(i-1, max) &lt; 0.4) outlier = 6;
 
         outlier = 1;
 
         <span class="keywordflow">if</span>(i == 1){
             plot_waves += <span class="stringliteral">&quot;plot&quot;</span>;
             plot_pca += <span class="stringliteral">&quot;plot&quot;</span>;
         }
         <span class="keywordflow">else</span>{
             plot_waves += <span class="stringliteral">&quot;,&quot;</span>;
             plot_pca += <span class="stringliteral">&quot;,&quot;</span>;
         }
 
         plot_waves += <span class="stringliteral">&quot; &#39;output/gnuplot_inputwaves.txt&#39; u &quot;</span> + QString::number(i) +
                 <span class="stringliteral">&quot;with lines lt 1 lc &quot;</span> + QString::number(max);
 
         plot_pca += <span class="stringliteral">&quot; &#39;output/pca_out.txt&#39; every ::&quot;</span> + QString::number(i - 1) + <span class="stringliteral">&quot;::&quot;</span> + QString::number(i - 1) +
                 <span class="stringliteral">&quot; lt &quot;</span> + QString::number(outlier) + <span class="stringliteral">&quot; lc &quot;</span> + QString::number(max);
 
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++){
 
         plot_ellipses += <span class="stringliteral">&quot;, &#39;output/ellipses.dat&#39; every ::&quot;</span> + QString::number(i) + <span class="stringliteral">&quot;::&quot;</span> + QString::number(i) +
                 <span class="stringliteral">&quot; lc &quot;</span> + QString::number(i) + <span class="stringliteral">&quot; with ellipses&quot;</span>;
 
         <span class="keywordflow">if</span>(i == 0)
             plot_hist += <span class="stringliteral">&quot;plot&quot;</span>;
         <span class="keywordflow">else</span>
             plot_hist += <span class="stringliteral">&quot;,&quot;</span>;
 
         plot_hist += <span class="stringliteral">&quot; &#39;output/pi.dat&#39; every ::&quot;</span> + QString::number(i) + <span class="stringliteral">&quot;::&quot;</span> + QString::number(i) +
                 <span class="stringliteral">&quot; lc &quot;</span> + QString::number(i) + <span class="stringliteral">&quot; with histograms&quot;</span>;
 
     }
 
     plot_waves += <span class="stringliteral">&quot;\n&quot;</span>;
     fprintf(gp, plot_waves.toStdString().c_str());
     fflush(gp);
 
     fprintf(gp, plot_pca.toStdString().c_str());
     fflush(gp);
 
     fprintf(gp, <span class="stringliteral">&quot;, &#39;output/em.dat&#39; lt 3&quot;</span>);
 
     plot_ellipses += <span class="stringliteral">&quot;\n&quot;</span>;
     fprintf(gp, plot_ellipses.toStdString().c_str());
     fflush(gp);
 
     plot_hist += <span class="stringliteral">&quot;\n&quot;</span>;
     fprintf(gp, plot_hist.toStdString().c_str());
     fflush(gp);
 
     plot_process = <span class="stringliteral">&quot;!ps2pdf plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.ps plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.pdf\n&quot;</span>
             <span class="stringliteral">&quot;!rm plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.ps\n&quot;</span>
             <span class="stringliteral">&quot;!convert -density 300 plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.pdf plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.jpeg\n&quot;</span>;
 
     <span class="keywordtype">int</span> frames_per_image = 30; <span class="comment">// for video only (set it to 1 if the video is not needed)</span>
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 1; l &lt; frames_per_image; l++)
         plot_process += <span class="stringliteral">&quot;!cp plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.jpeg plot/out&quot;</span> + QString::number(iter + l) + <span class="stringliteral">&quot;.jpeg\n&quot;</span>;
 
     fprintf(gp, plot_process.toStdString().c_str());
     fflush(gp);
 
     fprintf(gp, <span class="stringliteral">&quot;unset multiplot\n&quot;</span>);
 
     pclose(gp);
 
     iter += frames_per_image;
 
 }
</pre></div><p><a class="anchor" id="Functionrun_Shoham"></a> </p>
<h4>Function: run_Shoham</h4>
<p>runs the ShohamEM algorithm on given datapoints and means (new Version)</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::run_Shoham(){
 
     std::fstream file_like;
     file_like.open(<span class="stringliteral">&quot;output/likelihood.dat&quot;</span>, std::ios::out);
 
     initialize_Shoham();
 
     dump();
 
     <span class="keywordtype">int</span> iter = 0;
     T v_old;
     T L_old;
 
     <span class="keywordflow">while</span>(g &gt;= g_min){
 
         <span class="keywordflow">do</span>{
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> o = 0; o &lt; g; o++)
                 std::cout &lt;&lt; pi[o];
 
             v_old = v;
             L_old = L;
 
             e_step_Shoham();
 
             m_step_Shoham();
</pre></div><p>update P_ij</p>
<div class="fragment"><pre class="fragment">             assemble_P_ij(gamma, v, p, n_data_points, g,
                           Delta.array().val(),
                           delta_ij.array().val(),
                           P_ij.array().val());
</pre></div><p>update L</p>
<div class="fragment"><pre class="fragment">             pi_d  = pi;
 
             Vector c_d;
 
             c_d = P_ij * pi_d;
 
             <span class="keywordtype">double</span> log_1 = 0.;
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt; g; j++)
                 log_1 += std::log(n_data_points*pi[j]/12);
 
             <span class="keywordtype">double</span> loglike_3 = (N/2)*log_1+(g/2)+(g*(N+1)/2);
 
             T sum;
             sum = sum_array(n_data_points, c_d.array().val(), <span class="keyword">true</span>);
 
             L = sum - loglike_3;
 
             printf(<span class="stringliteral">&quot;###################loglike = %f ########################\n&quot;</span>, L);
 
         } <span class="keywordflow">while</span>(std::fabs(L_old - L) &gt;= 0.1 || std::fabs(v - v_old) &gt;= 0.01);
 
         dump();
 
         file_like &lt;&lt; L &lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt;L_max &lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;v&lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::fabs(L_old - L) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt;std::fabs(v - v_old)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;g&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
         flush(file_like);
 
         <span class="keywordflow">if</span>(L &gt;= L_max + L_max * 0.09 &amp;&amp; g &gt; g_min){
 
             L_max = L;
 
             pi_opt.resize(pi.size());
             std::copy(pi.begin(), pi.end(), pi_opt.begin());
             mu_opt = mu;
             Sigma_opt.resize(Sigma.size());
             std::copy(Sigma.begin(), Sigma.end(), Sigma_opt.begin());
             v_opt = v;
             u_ij_opt = u_ij;
             z_ij_opt = z_ij;
             P_ij_opt = P_ij;
 
             <span class="keywordtype">int</span> min = 0;
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; pi.size(); i++)
                 <span class="keywordflow">if</span>(pi[i] &lt; pi[min])
                     min = i;
 
             pi[min] = 0;
 
             purge_step_Shoham();
 
         }
         <span class="keywordflow">else</span>
             <span class="keywordflow">break</span>;
 
         iter++;
 
     }
 
     g++;
     pi = pi_opt;
     mu = mu_opt;
     Sigma = Sigma_opt;
     v = v_opt;
     u_ij = u_ij_opt;
     z_ij = z_ij_opt;
     P_ij = P_ij_opt;
 
     dump();
 
     file_like.close();
 
 }
</pre></div><p><a class="anchor" id="Functioninitialize_Shoham"></a> </p>
<h4>Function: initialize_Shoham</h4>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::initialize_Shoham()
 {
     it = 0;
     dealii::IdentityMatrix I(p);
 
     mu = mean; <span class="comment">// cluster centers previous calculated by k-means</span>
</pre></div><p>g = g_max already set in constructor</p>
<div class="fragment"><pre class="fragment">     g_min = 1;
 
     pi.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         pi[i] = 1./g;
 
     Sigma.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         Sigma[i] = I;
 
     v = 50;
 
     L_max = -1. * std::numeric_limits&lt;T&gt;::max(); <span class="comment">// -infinity</span>
 
     N = 0.1;<span class="comment">//p;</span>
 
     u_ij.reinit(n_data_points, g);
     z_ij.reinit(n_data_points, g);
     P_ij.reinit(n_data_points, g);
 
     delta_ij.reinit(n_data_points, g);
     Delta.reinit(g);
 
     Sigma_inv.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         Sigma_inv[i] = I;
 
     Sigma_dec.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         Sigma_dec[i] = I;
 
     M.reinit(n_data_points, p);
 
     iter = 0;
 
 
 }
</pre></div><p><a class="anchor" id="Functione_step_Shoham"></a> </p>
<h4>Function: e_step_Shoham</h4>
<p>E Step of ShohamEM algorithm (update z and u)</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::e_step_Shoham()
 {
 
     Matrix tmp(p, n_data_points);
     Vector c_d;
     std::vector&lt;T&gt; Delta_h(g);
 
     gamma = tgamma((v+p)/2) / (tgamma(v/2)*(std::pow((M_PI*v),(p/2.))));
</pre></div><p>--- calculate delta_ij</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;g;j++)
         Delta_h[j] = 1.;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; g; k++){
 
         subtract_array_from_matrix(n_data_points, p, k, g,
                                    data.array().val(),
                                    mu.array().val(),
                                    M.array().val());
 
         tmp = Sigma_inv[k] * tr(M);
 
         MM_scalar(n_data_points, p,
                   M.array().val(),
                   tmp.array().val(),
                   delta_ij.array().val() + k * n_data_points);
     }
 
 
     FullMatrixAccessor delta_ij_h(n_data_points, g, <span class="keyword">true</span>);
     delta_ij_h = delta_ij;
     dealii::Vector&lt;T&gt; delta_ij_array(n_data_points * g);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;n_data_points; i++){ <span class="comment">// transpose</span>
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g; j++){
             delta_ij_array(j*n_data_points+i) = delta_ij(i,j);
         }
     }
 
     <span class="keyword">typename</span> dealii::Vector&lt;T&gt;::const_iterator max_delta = std::max_element(delta_ij_array.begin(), delta_ij_array.end());
     <span class="keyword">typename</span> dealii::Vector&lt;T&gt;::const_iterator min_delta = std::min_element(delta_ij_array.begin(), delta_ij_array.end());
 
     T interval = *max_delta - *min_delta;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;n_data_points*g; i++){
         delta_ij_array(i) -= *min_delta;
     }
     delta_ij_array /= interval;
 
 
     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_intervals = 50;
     dealii::Histogram Histogram;
     Histogram.evaluate(delta_ij_array, n_intervals, Histogram.linear);
 
     std::string delta_gram = <span class="stringliteral">&quot;output/delta_gram.dat&quot;</span>;
     std::ofstream dg(delta_gram.c_str());
     Histogram.write_gnuplot(dg);
 
     Delta = Delta_h;
 
     printf(<span class="stringliteral">&quot;gamma = %f\n&quot;</span>, gamma);
 
     assemble_P_ij(gamma, v, p, n_data_points, g,
                   Delta.array().val(),
                   delta_ij.array().val(),
                   P_ij.array().val());
 
     pi_d  = pi;
 
     c_d = P_ij * pi_d;
</pre></div><p>--- update z_ij</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">if</span>(it++==0)
         assemble_z_ij(n_data_points, g,
                       P_ij.array().val(),
                       c_d.array().val(),
                       pi_d.array().val(),
                       z_ij.array().val());
</pre></div><p>--- update u_ij</p>
<div class="fragment"><pre class="fragment">     assemble_u_ij(v, p, n_data_points, g,
                   delta_ij.array().val(),
                   u_ij.array().val());
 
 }
</pre></div><p><a class="anchor" id="Functionm_step_Shoham"></a> </p>
<h4>Function: m_step_Shoham</h4>
<p>M Step of ShohamEM algorithm</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::m_step_Shoham()
 {
 
     <span class="keywordtype">double</span> digamma;
     Matrix P_ij_tmp = P_ij;
     Matrix z_ij_tmp = z_ij;
     Matrix q_ij(n_data_points, g);
     dealii::IdentityMatrix I(p);
</pre></div><p>calculate y</p>
<div class="fragment"><pre class="fragment">     digamma = boost::math::digamma((p+v)/2.);
 
     <span class="keywordtype">double</span> y = calculate_y(n_data_points,
                            g,
                            v,
                            digamma,
                            z_ij.array().val(),
                            delta_ij.array().val(),
                            u_ij.array().val());
 
     y /= -n_data_points;
</pre></div><p>y musst be greater than 1, because of the calculation of the DOF parameter.</p>
<div class="fragment"><pre class="fragment">     y = std::max(y, 2.);
     printf(<span class="stringliteral">&quot;y = %f \n&quot;</span>, y);
</pre></div><p>update pi[j]</p>
<div class="fragment"><pre class="fragment">     z_ij_tmp = z_ij;
     T max, sum_pi = 2., tmp_sum[g];
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         tmp_sum[j] = 0.;
     }
 
     <span class="keywordtype">int</span> rel[g];
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++) rel[i] = 0;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n_data_points; i++){
 
         <span class="keywordtype">int</span> max = 0;
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 1; j &lt; g; j++)
             <span class="keywordflow">if</span>(z_ij(i, j) &gt; z_ij(i, max))
                 max = j;
 
         rel[max]++;
 
     }
 
     <span class="keywordtype">int</span> s = 0;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         s+=rel[i];
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         pi[i] = ((<span class="keywordtype">double</span>) rel[i]+1) / (double) s;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         std::cout &lt;&lt; pi[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
 
     purge_step_Shoham();
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         std::cout &lt;&lt; pi[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
 
     fflush(stdout);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         <span class="keywordflow">if</span>(pi[i] &lt; 0.001) exit(0);
</pre></div><p>update mu[j] calculate sum(1-n)z_ij*u_ij</p>
<div class="fragment"><pre class="fragment">     T zxu[g];
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;g; i++){
         zxu[i] = 0.;
     }
 
     sum_array2D(n_data_points, g,
                 z_ij.array().val(),
                 u_ij.array().val(),
                 zxu);
</pre></div><p>calculate z_ij*u_ij = q_ij</p>
<div class="fragment"><pre class="fragment">     MxM(n_data_points, g,
         z_ij.array().val(),
         u_ij.array().val(),
         q_ij.array().val());
</pre></div><p>update mu[j]</p>
<div class="fragment"><pre class="fragment">     mu = tr(q_ij) * data;
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;g; i++){
         MatrixSubRow mu_sub(mu,i,0);
         mu_sub *= 1./zxu[i];
     }
</pre></div><p>update Sigma[j]</p>
<div class="fragment"><pre class="fragment">     M.reinit(n_data_points, p);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         SMX(n_data_points,
             p,
             q_ij.array().val(),
             zxu[j],
             j,
             data.array().val(),
             mu.array().val(),
             M.array().val()
             );
 
         Sigma[j] = tr(M)*M;
     }
</pre></div><p>calculate Delta[j] and Sigma_inv[j]</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">int</span> Matrix_Size = ((p+step1::DEFAULT_TILE_SIZE-1)/step1::DEFAULT_TILE_SIZE)*step1::DEFAULT_TILE_SIZE;
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k &lt; g; k++){
</pre></div><p>cholesky decomposition Save the small Matrix in a Matrix TILE_SIZE <img class="formulaInl" alt="$\times$" src="form_151.png"/> TILE_SIZE to use the Cholesky decomposition from Step_1</p>
<div class="fragment"><pre class="fragment">         Matrix cholMatrix;
         dealii::IdentityMatrix eye(Matrix_Size);
         cholMatrix = eye;
 
         SubMatrix Sub_cholMatrix(cholMatrix, 0, p, 0 , p);
 
         Sub_cholMatrix = Sigma[k];
 
         step1::Kernels&lt;T&gt; fac_backend;
 
         fac_backend.cholesky.blackbox(cholMatrix.array().val(), cholMatrix.n_cols(), cholMatrix.leading_dim);
 
         SubMatrix Sub_Sigma(Sigma_dec[k], 0,0);
 
         Sub_Sigma = cholMatrix;
 
         T det = 0.;
 
         det = Det(p, Matrix_Size, Sub_cholMatrix.array().val());
         Delta.add(k, det);
 
         Matrix Identity = I;
         Matrix X(p,p);
 
         Sigma_inv[k] = Sigma_dec[k];
         <span class="keyword">const</span> SubMatrix l_d(Sigma_dec[k],0,0);
         <span class="keyword">const</span> SubMatrix rhs(Identity, 0,0);
         SubMatrix x_d(X,0,0);
         SubMatrix inv(Sigma_inv[k],0,0);
 
         RightMSolveTr&lt;T, blas&gt; L_X(trSub(l_d),x_d);
         L_X = rhs;
 
         RightMSolve&lt;T, blas&gt; L_B(l_d, inv);
         L_B = x_d;
 
     }
</pre></div><p>update DOF parameter</p>
<div class="fragment"><pre class="fragment">     <span class="keywordtype">double</span> errfunc = boost::math::erf(0.6594*log(2.1971/(y+log(y)-1)));
     v = (2/(y+log(y)-1))+0.0416*(1+errfunc);
 
     printf(<span class="stringliteral">&quot;n_dofs_t_distro = %f\n&quot;</span>, v);
 
 }
</pre></div><p><a class="anchor" id="Functionpurge_step_Shoham"></a> </p>
<h4>Function: purge_step_Shoham</h4>
<p>purges components in ShohamEM algorithm</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::purge_step_Shoham()
 {
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pi.size(); i++){
 
         <span class="keywordflow">if</span>(pi[i] &lt; 0.0001 &amp;&amp; g&gt;g_min){
</pre></div><p>update pi</p>
<div class="fragment"><pre class="fragment">             pi[i] = pi[g-1];
             pi.resize(g-1);
</pre></div><p>update sigma</p>
<div class="fragment"><pre class="fragment">             Sigma[i] = Sigma[g-1];
             Sigma.resize(g-1);
</pre></div><p>update P_ij</p>
<div class="fragment"><pre class="fragment">             MatrixSubCol subPij_target(P_ij, 0, i);
             MatrixSubCol subPij_source(P_ij, 0, g-1);
             subPij_target = subPij_source;
 
             Matrix new_Pij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Pij, 0, j);
                 MatrixSubCol from(P_ij, 0, j);
 
                 to = from;
 
             }
 
             P_ij = new_Pij;
</pre></div><p>update delta_ij</p>
<div class="fragment"><pre class="fragment">             MatrixSubCol subDeltaij_target(P_ij, 0, i);
             MatrixSubCol subDeltaij_source(P_ij, 0, g-1);
             subDeltaij_target = subDeltaij_source;
 
             Matrix new_Deltaij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Deltaij, 0, j);
                 MatrixSubCol from(delta_ij, 0, j);
 
                 to = from;
 
             }
 
             delta_ij = new_Deltaij;
</pre></div><p>update mu;</p>
<div class="fragment"><pre class="fragment">             MatrixSubRow subMu_target(mu, i, 0);
             MatrixSubRow subMu_source(mu, g-1, 0);
             subMu_target = subMu_source;
 
             Matrix new_mu(g-1, p);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubRow to(new_mu, j, 0);
                 MatrixSubRow from(mu, j, 0);
 
                 to = from;
 
             }
 
             mu = new_mu;
</pre></div><p>update u_ij</p>
<div class="fragment"><pre class="fragment">             MatrixSubCol subUij_target(u_ij, 0, i);
             MatrixSubCol subUij_source(u_ij, 0, g-1);
             subUij_target = subUij_source;
 
             Matrix new_Uij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Uij, 0, j);
                 MatrixSubCol from(u_ij, 0, j);
 
                 to = from;
 
             }
 
             u_ij = new_Uij;
</pre></div><p>update z_ij</p>
<div class="fragment"><pre class="fragment">             MatrixSubCol subZij_target(z_ij, 0, i);
             MatrixSubCol subZij_source(z_ij, 0, g-1);
             subZij_target = subZij_source;
 
             Matrix new_Zij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Zij, 0, j);
                 MatrixSubCol from(z_ij, 0, j);
 
                 to = from;
 
             }
 
             z_ij = new_Zij;
</pre></div><p>update Delta</p>
<div class="fragment"><pre class="fragment">             Delta.set(i, Delta(g-1));
             Vector newDelta;
             newDelta.reinit(g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++)
                 newDelta.set(j, Delta(j));
 
             Delta = newDelta;
</pre></div><p>update Sigma_inv</p>
<div class="fragment"><pre class="fragment">             Sigma_inv[i] = Sigma_inv[g-1];
             Sigma_inv.resize(g-1);
</pre></div><p>update Sigma_dec</p>
<div class="fragment"><pre class="fragment">             Sigma_dec[i] = Sigma_dec[g-1];
             Sigma_dec.resize(g-1);
 
             g--;
 
             <span class="keywordflow">if</span>(pi[i] == 0) <span class="comment">// copied one is zero</span>
                 i--;
 
             purge_step_Shoham();
 
             <span class="keywordflow">break</span>;
 
         }
 
     }
 
 }
</pre></div><p><a class="anchor" id="DestructorShohamEM"></a> </p>
<h4>Destructor : ~ShohamEM</h4>
<p>Free the memory taken by ShohamEM and shuts down the blas library.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::ShohamEM&lt;T, blas&gt;::~ShohamEM()
 {
     BW::Shutdown();
 }
</pre></div><p><a class="anchor" id="ConstructorKernelTest"></a> </p>
<h4>Constructor: KernelTest</h4>
<p>Initilize the Kernel performance tests </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">n_data_points</td><td>: number of datapoints. </td></tr>
    <tr><td class="paramname">dim</td><td>: dimension (number of columns). </td></tr>
    <tr><td class="paramname">n_clusters</td><td>: number of clusters.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::KernelTest&lt;T, blas&gt;::KernelTest(<span class="keywordtype">int</span> n_data_points, <span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> n_clusters)
     :
       n_data_points(n_data_points), dim(dim),
       n_clusters(n_clusters)
 {
     BW::Init();
 }
</pre></div><p><a class="anchor" id="Functionrun"></a> </p>
<h4>Function: run</h4>
<p>runs the KernelTest</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::KernelTest&lt;T, blas&gt;::run()
 {
     <span class="keywordtype">int</span> Matrix_Size = ((dim+step1::DEFAULT_TILE_SIZE-1)/step1::DEFAULT_TILE_SIZE)*step1::DEFAULT_TILE_SIZE;
 
     FullMatrixAccessor Test_Matrix(n_data_points, dim, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix2(n_clusters, dim, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix3(n_data_points, dim, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix4(dim, n_data_points, <span class="keyword">true</span>);
 
     FullMatrixAccessor Test_Matrix_ij(n_data_points, n_clusters, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix_ij2(n_data_points, n_clusters, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix_ij3(n_data_points, n_clusters, <span class="keyword">true</span>);
 
     std::vector&lt;T&gt; Delta_h(n_clusters);
     std::vector&lt;T&gt; c_h(n_data_points);
     std::vector&lt;T&gt; pi_h(n_clusters);
     Vector Delta, c, pi;
 
     T zxu[n_clusters];
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;n_clusters; i++){
         zxu[i] = 0.;
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; n_data_points; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;dim; j++){
             Test_Matrix(i,j) = (i+1)/10.;
             Test_Matrix3(i,j) = 0.;
             Delta_h[j] = 1.;
             c_h[i] = 1.;
             pi_h[j] = 1/n_clusters;
         }
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; n_clusters; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;dim; j++){
             Test_Matrix2(i,j) = (i+1)/10.;
         }
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; dim; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n_data_points; j++){
             Test_Matrix4(i,j) = (i+1)/10.;
         }
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; n_data_points; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n_clusters; j++){
             Test_Matrix_ij(i,j) = (i+1)/10.;
             Test_Matrix_ij2(i,j) = (i+1)/10.;
             Test_Matrix_ij3(i,j) = (i+1)/10.;
         }
     }
 
     Matrix Test, Test2, Test3, Test4, Test_ij, Test_ij2, Test_ij3;
     Test = Test_Matrix;
     Test2 = Test_Matrix2;
     Test3 = Test_Matrix3;
     Test4 = Test_Matrix4;
     Test_ij = Test_Matrix_ij;
     Test_ij2 = Test_Matrix_ij2;
     Test_ij3 = Test_Matrix_ij3;
     Delta = Delta_h;
     c = c_h;
     pi = pi_h;
 
     subtract_array_from_matrix(n_data_points, dim, 1, n_clusters,
                                Test.array().val(),
                                Test2.array().val(),
                                Test3.array().val());
 
     printf(<span class="stringliteral">&quot;dim = %d\n&quot;</span>, dim);
 
 
     MM_scalar(n_data_points, dim,
               Test3.array().val(),
               Test4.array().val(),
               Test.array().val());
 
     Det(dim, Matrix_Size, Test3.array().val());
 
     assemble_P_ij(0.5, 50, dim, n_data_points, n_clusters,
                   Delta.array().val(),
                   Test_ij.array().val(),
                   Test_ij2.array().val());
 
     assemble_u_ij(50, dim, n_data_points, n_clusters,
                   Test_ij.array().val(),
                   Test_ij2.array().val());
 
     assemble_z_ij(n_data_points, n_clusters,
                   Test_ij.array().val(),
                   c.array().val(),
                   pi.array().val(),
                   Test_ij2.array().val());
 
     calculate_y(n_data_points, n_clusters, 0.5, 13,
                 Test_ij.array().val(),
                 Test_ij2.array().val(),
                 Test_ij3.array().val());
 
     sum_array(n_data_points, c.array().val(), <span class="keyword">false</span>);
 
     sum_array2D(n_data_points, n_clusters,
                 Test_ij.array().val(),
                 Test_ij2.array().val(),
                 zxu);
 
     MxM(n_data_points, n_clusters,
         Test_ij.array().val(),
         Test_ij2.array().val(),
         Test_ij3.array().val());
 
     SMX(n_data_points, dim,
         Test_ij.array().val(),
         zxu[2],
         2,
         Test.array().val(),
         Test2.array().val(),
         Test3.array().val());
 }
</pre></div><p><a class="anchor" id="DestructorKernelTest"></a> </p>
<h4>Destructor : ~KernelTest</h4>
<p>Free the memory taken by KernelTest and shuts down the blas library.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::KernelTest&lt;T, blas&gt;::~KernelTest()
 {
     BW::Shutdown();
 }
<span class="preprocessor"> #endif // CUDA_DRIVER_STEP_7_HH</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
</pre></div><p>STL header</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
 
<span class="preprocessor"> #include &lt;QString&gt;</span>
</pre></div><p>Driver for the GPU-Part</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cuda_driver_step-7.h&gt;</span>
</pre></div><p>deal.II-Komponenten</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;deal.II/lac/matrix_out.h&gt;</span>
</pre></div><p>cublas-Wrapper-Classes.<br/>
 attach all the needed header-files.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cuda_driver_step-7.hh&gt;</span>
 
<span class="preprocessor"> #include &lt;waveforms_generator.h&gt;</span>
</pre></div><p>Reuse GlobalData and the Params classes from step-4.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;step-4.hh&gt;</span>
</pre></div><p>Use NIPALS from step-5</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cuda_driver_step-5.h&gt;</span>
<span class="preprocessor"> #include &lt;cuda_driver_step-5.hh&gt;</span>
 
 <span class="keyword">namespace </span>step7 {
</pre></div><p><a class="anchor" id="ClassSimParams"></a> </p>
<h3>Class: SimParams</h3>
<p>contains the the parameter needed to run the simulation</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keyword">struct </span>SimParams : <span class="keyword">public</span> step4::QRTestUIParams
<span class="preprocessor">         #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>         , step6::SimParam
<span class="preprocessor">         #endif</span>
<span class="preprocessor"></span> 
 {
 
     <span class="keyword">typedef</span> step4::QRTestUIParams Base1;
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> step6::SimParam Base2;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     SimParams() : Base1()
   #ifdef USE_KMEANS
       , Base2()
   #endif
     {}
 
     <span class="keyword">static</span> <span class="keywordtype">void</span> declare(dealii::ParameterHandler &amp; prm);
 
     <span class="keywordtype">void</span> <span class="keyword">get</span>(dealii::ParameterHandler &amp; prm);
</pre></div><p>waveforms parameter</p>
<div class="fragment"><pre class="fragment">     dealii::FullMatrix&lt;T&gt; waveforms;
     dealii::FullMatrix&lt;T&gt; check_waves;
 
     <span class="keywordtype">int</span> n_forms, n_rows, n_cols;
     <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> forms = 3;
     T noise;
     std::vector&lt;double&gt; waves_parameters;
     std::vector&lt;int&gt; n_waves;
     QString number_of_waves;
     std::string output_folder;
 
     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components, max_iter;
 
     <span class="keywordtype">double</span> ev_tol;
 
 <span class="keyword">public</span>:
 
     <span class="keywordtype">void</span> generate_waveforms();
 
 };
</pre></div><p><a class="anchor" id="ClassPCA"></a> </p>
<h3>Class: PCA</h3>
<p>contains all the needed variables and function for the PCA</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt; <span class="keyword">class </span>PCA {
 
 <span class="keyword">public</span>:
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix       Matrix;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;              tr;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix    SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector       Vector;
 
 
     PCA(dealii::ParameterHandler &amp; prm);
     <span class="keywordtype">void</span> run();
 
 
     Matrix Q_x_scores;
     Matrix d_scores;
     Matrix d_loadings;
 
 <span class="keyword">private</span>:
     <span class="keywordtype">void</span> factorize(dealii::FullMatrix&lt;T&gt; &amp;A);
 
     <span class="keywordtype">void</span> check_results(<span class="keyword">const</span> dealii::FullMatrix&lt;T&gt; &amp; A,
                        <span class="keyword">const</span> step4::CudaQRDecomposition&lt;T, blas&gt;&amp; QRf,
                        T elapsed_time);
 
     <span class="keywordtype">void</span> save_results();
 
     dealii::FullMatrix&lt;T&gt; Q, B, P_t, H;
 
     SimParams&lt;T&gt; params;
 
     dealii::ConvergenceTable results_table;
 
     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_successful_measurements;
 };
</pre></div><p><a class="anchor" id="ClassMyFancySimulation"></a> </p>
<h3>Class: MyFancySimulation</h3>
<p>This class controls the actual simulation for the physical problem.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keyword">class </span>MyFancySimulation {
 
 <span class="keyword">public</span>:
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix       Matrix;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;              tr;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix    SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector       Vector;
 
     MyFancySimulation(std::string prm_filename);
 
     <span class="keywordtype">void</span> run();
 
     <span class="keywordtype">void</span> run_pca(dealii::ParameterHandler &amp;prm_handler);
 
     <span class="keywordtype">void</span> run_cluster_analysis();
 
 <span class="keyword">private</span>:
 
     SimParams&lt;T&gt; params;
 
     FullMatrixAccessor data;
     FullMatrixAccessor loadings;
     FullMatrixAccessor  scores;
 };
</pre></div><p><a class="anchor" id="ConstructorPCA"></a> </p>
<h4>Constructor: PCA</h4>
<p>Init the PCA class the get the needed parameter from the .prm file </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prm</td><td>: dealii parameter handler.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::PCA&lt;T, blas&gt;::PCA(dealii::ParameterHandler &amp;prm)
     :
       n_successful_measurements(0)
 {
     params.get(prm);
 }
</pre></div><p><a class="anchor" id="Functionrun"></a> </p>
<h4>Function: run</h4>
<p>generates Data for the PCA and calls the factorize function</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::PCA&lt;T, blas&gt;::run() {
 
     params.generate_waveforms();
</pre></div><p>write the calculated means and covariances to the files means.txt and sig.txt respectively</p>
<div class="fragment"><pre class="fragment">     std::string wforms = <span class="stringliteral">&quot;output/wforms.txt&quot;</span>;
     std::ofstream wf(wforms.c_str());
     params.waveforms.print(wf, 12 / *width; avoids that two numbers appear as one in the output* /);
 
     factorize(params.waveforms);
 
 }
</pre></div><p><a class="anchor" id="Functionfactorize"></a> </p>
<h4>Function: factorize</h4>
<p>runs the QR-Decomposition on the Data-Matrix followes by the PCA using the nipals Algorithm </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>: input Matrix.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span>
 step7::PCA&lt;T, blas&gt;::factorize(dealii::FullMatrix&lt;T&gt; &amp;A)
 {
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- FACTORIZE ----------&quot;</span> &lt;&lt; std::endl;
 
     step4::CudaQRDecomposition&lt;T, blas&gt; QR;
 
     QR.householder(A);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
     FullMatrixAccessor R_tmp;
     R_tmp = QR.R();
 
 
     dealii::FullMatrix&lt;T&gt; R_tmp_h(R_tmp.n_rows(), R_tmp.n_cols());
 
     std::ofstream R_out(<span class="stringliteral">&quot;output/R_mea.dat&quot;</span>);
 
     std::cout&lt;&lt; <span class="stringliteral">&quot;R dimensions = &quot;</span> &lt;&lt; R_tmp.n_rows() &lt;&lt; <span class="stringliteral">&quot; X &quot;</span> &lt;&lt; R_tmp.n_cols() &lt;&lt; std::endl;
     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; R_tmp_h.n_rows(); ++r)
     {
         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; R_tmp_h.n_cols(); ++c)
         {
             R_tmp_h(r, c) = R_tmp(r, c);
             R_out &lt;&lt; R_tmp_h(r, c) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
         }
         R_out  &lt;&lt; std::endl;
     }
     std::cout  &lt;&lt; std::endl;
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- NIPALS ----------&quot;</span> &lt;&lt; std::endl;
 
     step5::CudaNIPALS&lt;T, blas&gt; nipals(params.n_components,
                                       -1/ *params.max_iter* /,
                                       params.ev_tol);
 
     nipals.get_pca(R_tmp_h);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
     nipals.lambda.print(std::cout);
 
 
     Q_x_scores.reinit(params.n_rows,params.n_components);
 
     SubMatrix sub_Q(const_cast&lt;Matrix &amp;&gt;(QR.Q()),0,params.n_rows,0,params.n_cols);
 
     SubMatrix scores(const_cast&lt;Matrix &amp;&gt;(nipals.scores()),0,0);
 
     SubMatrix Q_x_s(const_cast&lt;Matrix &amp;&gt;(Q_x_scores),0,0);
 
 
     d_scores.reinit(nipals.scores().n_rows(), nipals.scores().n_cols());
     d_scores = nipals.scores();
 
     d_loadings.reinit(nipals.loads().n_rows(),nipals.loads().n_cols());
     d_loadings = nipals.loads();
 
     Matrix Q_tmp, S_tmp, P_tmp;
     Q_tmp = QR.Q();
     S_tmp = nipals.scores();
     P_tmp = Q_tmp * S_tmp;
 
     Q_x_scores = P_tmp;
 
     std::ofstream PCA_out(<span class="stringliteral">&quot;output/pca_out.txt&quot;</span>);
     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; P_tmp.n_rows(); r++){
         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; P_tmp.n_cols(); c++)
             PCA_out&lt;&lt;P_tmp(r,c)&lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>;
         PCA_out&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
     }
 
 }
</pre></div><p><a class="anchor" id="Functiondeclare"></a> </p>
<h4>Function: declare</h4>
<p>Declares the input parameter for the dealII Parameter Handler </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prm</td><td>: dealii parameter handler.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::SimParams&lt;T&gt;::declare(dealii::ParameterHandler &amp;prm)
 {
     Base1::declare(prm);
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     Base2::declare(prm);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     prm.enter_subsection(<span class="stringliteral">&quot;Waveforms parameters&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Number of waves&quot;</span>, <span class="stringliteral">&quot;300,300,300&quot;</span>,
                       dealii::Patterns::Anything(),
                       <span class="stringliteral">&quot;Number of Waves&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Noise intensity&quot;</span>, <span class="stringliteral">&quot;0.2&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Noise intensity&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Number of columns&quot;</span>, <span class="stringliteral">&quot;128&quot;</span>,
                       dealii::Patterns::Integer(),
                       <span class="stringliteral">&quot;Number of columns&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center of Wave 1&quot;</span>, <span class="stringliteral">&quot;0.25&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Center of Wave 1&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Sigma of Wave 1&quot;</span>, <span class="stringliteral">&quot;0.09&quot;</span>,
                       dealii::Patterns::Double(0.01,0.09),
                       <span class="stringliteral">&quot;Sigma of Wave 1 (standard deviation of gaussian)&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center of Wave 2&quot;</span>, <span class="stringliteral">&quot;0.85&quot;</span>,
                       dealii::Patterns::Double(0., 1.),
                       <span class="stringliteral">&quot;Center of Wave 2&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center 1 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.6&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Center 1 of Wave 3&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center 2 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.65&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Center 2 of Wave 3&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Sigma 1 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.05&quot;</span>,
                       dealii::Patterns::Double(0.01,0.09),
                       <span class="stringliteral">&quot;Sigma 1 of Wave 3 (Lorenz)&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Sigma 2 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.06&quot;</span>,
                       dealii::Patterns::Double(0.01,0.09),
                       <span class="stringliteral">&quot;Sigma 2 of Wave 3&quot;</span>);
 
     prm.declare_entry (<span class="stringliteral">&quot;Output folder&quot;</span>,
                        <span class="stringliteral">&quot;output&quot;</span>,
                        dealii::Patterns::Anything(),
                        <span class="stringliteral">&quot;output folder location&quot;</span>);
 
     prm.leave_subsection();
 
     prm.enter_subsection(<span class="stringliteral">&quot;NIPALS parameters&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Number of components&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,
                       dealii::Patterns::Integer(),
                       <span class="stringliteral">&quot;Number of components&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>,
                       dealii::Patterns::Integer(),
                       <span class="stringliteral">&quot;Maximal number of iterations. &quot;</span>
                       <span class="stringliteral">&quot;If -1 is given termination of NIPALS iterations &quot;</span>
                       <span class="stringliteral">&quot;solely depends on the given tolerance&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Tolerance for eigenvalues&quot;</span>,
                       <span class="stringliteral">&quot;1e-5&quot;</span>,
                       dealii::Patterns::Double(),
                       <span class="stringliteral">&quot;Once the relative change of an eigenvalue in the inner &quot;</span>
                       <span class="stringliteral">&quot;power iteration is les than the given value iteration &quot;</span>
                       <span class="stringliteral">&quot;stops and the next principal component is computed.&quot;</span>);
 
     prm.leave_subsection();
 
 }
</pre></div><p><a class="anchor" id="Functionget"></a> </p>
<h4>Function: get</h4>
<p>Reads the input parameters from the .prm file </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prm</td><td>: dealii parameter handler.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::SimParams&lt;T&gt;::get(dealii::ParameterHandler &amp;prm)
 {
 
     this-&gt;Base1::get(prm);
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     this-&gt;Base2::get(prm);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     prm.enter_subsection(<span class="stringliteral">&quot;Waveforms parameters&quot;</span>);
 
     number_of_waves = QString(prm.get(<span class="stringliteral">&quot;Number of waves&quot;</span>).c_str());
 
     noise = prm.get_double(<span class="stringliteral">&quot;Noise intensity&quot;</span>);
 
     n_cols = prm.get_integer(<span class="stringliteral">&quot;Number of columns&quot;</span>);
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center of Wave 1&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Sigma of Wave 1&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center of Wave 2&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center 1 of Wave 3&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center 2 of Wave 3&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Sigma 1 of Wave 3&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Sigma 2 of Wave 3&quot;</span>));
 
     output_folder = prm.get (<span class="stringliteral">&quot;Output folder&quot;</span>);
 
     QDir dir(<span class="stringliteral">&quot;plot&quot;</span>);
 
     <span class="keywordflow">if</span>(!dir.exists()){
         <span class="keywordtype">bool</span> mkdir = dir.mkpath(<span class="stringliteral">&quot;./&quot;</span>);
         AssertThrow(mkdir, dealii::ExcMessage(<span class="stringliteral">&quot;creating a new Folder failed&quot;</span>));
     }
 
     prm.leave_subsection();
 
     prm.enter_subsection(<span class="stringliteral">&quot;NIPALS parameters&quot;</span>);
 
     this-&gt;n_components = prm.get_integer(<span class="stringliteral">&quot;Number of components&quot;</span>);
 
     this-&gt;max_iter = prm.get_integer(<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>);
 
     this-&gt;ev_tol   = prm.get_double(<span class="stringliteral">&quot;Tolerance for eigenvalues&quot;</span>);
 
     prm.leave_subsection();
 
 }
</pre></div><p><a class="anchor" id="Functiongenerate_waveforms"></a> </p>
<h4>Function: generate_waveforms</h4>
<p>Generates a test matrix for the algorithm The data points are read from the .prm file</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::SimParams&lt;T&gt;::generate_waveforms()
 {
     QStringList number_list = number_of_waves.split(<span class="stringliteral">&quot;,&quot;</span>, QString::SkipEmptyParts);
 
     <span class="keywordflow">if</span>(number_list.size()&lt;forms)
     {
         std::cout&lt;&lt;<span class="stringliteral">&quot;more waves numbers needed!&quot;</span>&lt;&lt;std::endl;
         exit(1);
     }
 
     QStringList::iterator e = number_list.begin();
     QStringList::iterator end = number_list.end();
 
     <span class="keywordtype">int</span> i=0, sum = 0;
     n_waves.resize(forms);
     n_forms = 0;
</pre></div><p>Read the number of waves from the .prm file using split to seperate the string into single values</p>
<div class="fragment"><pre class="fragment">     <span class="keywordflow">for</span>(; e!= end; ++e, ++i)
     {
         <span class="keywordflow">if</span>(i==forms) <span class="keywordflow">break</span>;
         n_waves[i] = e-&gt;toInt();
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;forms;i++){
         sum += n_waves[i];
         <span class="keywordflow">if</span>(n_waves[i]!=0) n_forms++;
     }
 
     n_rows = sum;
 
     waveforms.reinit(n_rows,n_cols);
     check_waves.reinit(n_forms,n_cols);
     WaveForms::generate_waveforms(n_rows, n_cols, waveforms, n_waves, noise, waves_parameters);
     WaveForms::normalize_waveforms(n_rows, n_cols, waveforms);
     WaveForms::original_waveforms(n_cols,n_forms,check_waves, waves_parameters, n_waves);
</pre></div><p>Write the waveforms to File</p>
<div class="fragment"><pre class="fragment">     dealii::MatrixOut matrix_out;
     std::string wave_forms = output_folder+<span class="stringliteral">&quot;/waveforms.txt&quot;</span>;
     std::ofstream waf(wave_forms.c_str());
     matrix_out.build_patches(waveforms, <span class="stringliteral">&quot;waveforms&quot;</span>);
     matrix_out.write_gnuplot(waf);
</pre></div><p>Write the originalforms to File</p>
<div class="fragment"><pre class="fragment">     dealii::MatrixOut original_out;
     std::string original_forms = output_folder+<span class="stringliteral">&quot;/originalforms.txt&quot;</span>;
     std::ofstream oaf(original_forms.c_str());
     original_out.build_patches(check_waves, <span class="stringliteral">&quot;originalforms&quot;</span>);
</pre></div><p>original_out.write_gnuplot(oaf);</p>
<div class="fragment"><pre class="fragment"> }
 
 }
</pre></div><p><a class="anchor" id="ConstructorMyFancySimulation"></a> </p>
<h4>Constructor: MyFancySimulation</h4>
<p>The constructor initialize the simulation and calls the dealII parameter Handler to get the parameter from the .prm file </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">prm_filename</td><td>: name of the parameter file.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 step7::MyFancySimulation&lt;T&gt;::MyFancySimulation(std::string prm_filename)
 {
     dealii::ParameterHandler param_handler;
     SimParams&lt;T&gt;::declare(param_handler);
 
     param_handler.read_input(prm_filename);
     params.get(param_handler);
 }
</pre></div><p><a class="anchor" id="Funktionrun"></a> </p>
<h4>Funktion: run</h4>
<p>The real simulation will be started with the run() function</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::MyFancySimulation&lt;T&gt;::run()
 {
 
 
 }
 
 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::MyFancySimulation&lt;T&gt;::run_pca(dealii::ParameterHandler &amp;prm_handler)
 {
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;Householder-QR mit cublas :\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;
 
     PCA&lt;T, blas&gt; cublas_pca(prm_handler);
 
     cublas_pca.run();
     data = cublas_pca.Q_x_scores;
     loadings = cublas_pca.d_loadings;
     scores = cublas_pca.d_scores;
     std::cout &lt;&lt; <span class="stringliteral">&quot;\nHouseholder-QR mit cublas DONE \n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------\n&quot;</span> &lt;&lt; std::endl;
 
 }
</pre></div><p><a class="anchor" id="Funktionrun_cluster_analysis"></a> </p>
<h4>Funktion: run_cluster_analysis</h4>
<p>runs the clusteranalysis using The Shoham Algorithm or K-Means</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::MyFancySimulation&lt;T&gt;::run_cluster_analysis()
 {
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- START SIMULATION ----------&quot;</span> &lt;&lt; std::endl;
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- GENERATE WAVEFORMS ----------&quot;</span> &lt;&lt; std::endl;
 
     params.generate_waveforms();
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
     std::cout  &lt;&lt; std::endl;
 
     FullMatrixAccessor X(params.waveforms,<span class="keyword">true</span>);
 
     FullMatrixAccessor Y(params.check_waves, <span class="keyword">true</span>);
 
     dealii::FullMatrix&lt;T&gt; data_matrix2(params.n_rows, params.n_cols);
     dealii::FullMatrix&lt;T&gt; data_matrix2t(params.n_cols, params.n_rows);
     X.push_to(data_matrix2);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; params.n_rows; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; params.n_cols; j++){
             data_matrix2t(j, i) = data_matrix2(i, j);
         }
     }
 
     std::string sdata2 = <span class="stringliteral">&quot;output/data22.txt&quot;</span>;
     std::ofstream d2(sdata2.c_str());
     data_matrix2.print(d2, 12 / *width; avoids that two numbers appear as one in the output* /);
     std::string sdata2t = <span class="stringliteral">&quot;output/gnuplot_inputwaves.txt&quot;</span>;
     std::ofstream d2t(sdata2t.c_str());
     data_matrix2t.print(d2t, 12 / *width; avoids that two numbers appear as one in the output* /);
</pre></div><p>write clusters in separate files</p>
<div class="fragment"><pre class="fragment">     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span> 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- KMEANS ----------&quot;</span> &lt;&lt; std::endl;
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;n_clusters= &quot;</span> &lt;&lt; params.n_clusters &lt;&lt;std::endl;
 
     step6::Kmeans&lt;double, cublas&gt; cluster_search(data,params.mmeans,params.max_iter);
     cluster_search.initial_computation(params.method);
     cluster_search.iterate(params.method,params.max_iter);
</pre></div><p>write the calculated means and covariances to the files means.txt and sig.txt respectively</p>
<div class="fragment"><pre class="fragment">     std::string smmeans = <span class="stringliteral">&quot;output/mmeans.txt&quot;</span>;
     std::ofstream j(smmeans.c_str());
     params.mmeans.print(j, 12 / *width; avoids that two numbers appear as one in the output* /);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     dealii::ParameterHandler prm_debug_handler;
 
     FullMatrixAccessor means(params.mmeans, <span class="keyword">true</span>);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- SHOHAM ----------&quot;</span> &lt;&lt; std::endl;
 
     step7::ShohamEM&lt;T, cublas&gt; Test(data, means); <span class="comment">// data, means</span>
 
     Test.run_Shoham();
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE WITH SHOHAM----------&quot;</span> &lt;&lt; std::endl;
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
</pre></div><p>write the calculated means and covariances to the files means.txt and sig.txt respectively</p>
<div class="fragment"><pre class="fragment">     std::string smeans = <span class="stringliteral">&quot;output/means.txt&quot;</span>;
     std::ofstream m(smeans.c_str());
     params.mmeans.print(m, 12 / *width; avoids that two numbers appear as one in the output* /);
<span class="preprocessor"> #endif</span>
</pre></div><p>write the calculated original waveforms</p>
<div class="fragment"><pre class="fragment">     std::string oforms = <span class="stringliteral">&quot;output/oforms.txt&quot;</span>;
     std::ofstream of(oforms.c_str());
     params.check_waves.print(of, 12 / *width; avoids that two numbers appear as one in the output* /);
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
</pre></div><p>Write the waveforms to File</p>
<div class="fragment"><pre class="fragment">     dealii::MatrixOut means_out;
     std::string means_forms = params.output_folder+<span class="stringliteral">&quot;/means-waveforms.txt&quot;</span>;
     std::ofstream mf(means_forms.c_str());
     means_out.build_patches(params.mmeans, <span class="stringliteral">&quot;waveforms&quot;</span>);
     means_out.write_gnuplot(mf);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
 }
</pre></div><p><a class="anchor" id="Funktionrun_simulation"></a> </p>
<h4>Funktion: run_simulation</h4>
<p>Pass the user inputs from the main function to the simulation</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> run_simulation(<span class="keywordtype">int</span> / *argc* /, <span class="keywordtype">char</span> *argv[])
 {
</pre></div><p>the input parameters and reads from a file named like the program with the extension .prm. The read parameters are written to a log-file.</p>
<div class="fragment"><pre class="fragment">     dealii::ParameterHandler prm_handler;
 
<span class="preprocessor"> #ifdef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">float</span> NumberType;
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">double</span> NumberType;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     <span class="keyword">typedef</span> step7::SimParams&lt;NumberType&gt; SimParams;
 
     SimParams::declare(prm_handler);
 
     std::string prm_filename(argv[0]);
     prm_filename += <span class="stringliteral">&quot;.prm&quot;</span>;
     prm_handler.read_input (prm_filename);
 
     prm_filename += <span class="stringliteral">&quot;.log&quot;</span>;
     std::ofstream log_out_text(prm_filename.c_str());
     prm_handler.print_parameters (log_out_text,
                                   dealii::ParameterHandler::Text);
 
     SimParams params;
 
     params.get(prm_handler);
     <span class="keywordtype">int</span> DevNo = 0;
 
     cudaSetDevice(DevNo);           <span class="comment">// select CUDA device</span>
 
     global_data.current_device_id = DevNo;
 
     global_data.cublanc_gpu_info(); <span class="comment">// obtain informations about used GPU</span>
 
<span class="preprocessor"> #ifdef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span>     std::cout &lt;&lt; <span class="stringliteral">&quot;Simulation with float:\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;
</pre></div><p>Test with float</p>
<div class="fragment"><pre class="fragment">     step7::MyFancySimulation&lt;float&gt; simu_float(prm_filename);
 
     simu_float.run_pca(prm_handler);
 
     simu_float.run_cluster_analysis();
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;\nSimulation with float DONE \n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>     std::cout &lt;&lt; <span class="stringliteral">&quot;Simulation with double:\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;
 
     fflush(stdout);
</pre></div><p>Test with double</p>
<div class="fragment"><pre class="fragment">     step7::MyFancySimulation&lt;double&gt; simu_double(prm_filename);
 
     simu_double.run_pca(prm_handler);
 
     simu_double.run_cluster_analysis();
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;\nSimulation with double DONE \n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
 }
</pre></div><p><a class="anchor" id="Funktionrun_kerneltest"></a> </p>
<h4>Funktion: run_kerneltest</h4>
<p>Pass the user inputs from the main function to the simulation</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> run_kerneltest(<span class="keywordtype">int</span> / *argc* /, <span class="keywordtype">char</span> *argv[])
 {
 
     <span class="keywordtype">int</span> DevNo = 0;
 
     cudaSetDevice(DevNo);
<span class="preprocessor"> #ifdef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">float</span> NumberType;
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">double</span> NumberType;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_data_points = 100000;
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_sampling_points = 64;
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_clusters = 10;
 
     step7::KernelTest&lt;NumberType, cublas&gt; Test(n_data_points,
                                                n_sampling_points,
                                                n_clusters);
 
     Test.run();
 
 }
 
 <span class="keyword">namespace </span>step7 {
 
 }<span class="comment">// namespace step7 END</span>
</pre></div><p><a class="anchor" id="Funktionmain"></a> </p>
<h4>Funktion: main</h4>
<p>start of the simulation</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
 {
     cudaGetDeviceCount(&amp;global_data.n_CUDA_devices);
     std::cout
             &lt;&lt; <span class="stringliteral">&quot;N available CUDA devices: &quot;</span>
             &lt;&lt; global_data.n_CUDA_devices &lt;&lt; std::endl;
 
     run_simulation(argc, argv);
 
 }
</pre></div><p> <a class="anchor" id="Results"></a></p>
<h1>Results</h1>
<p>The actual not sorted input is depicted in the following plot. </p>
<div class="image">
<img src="waveforms3d.png" alt="waveforms3d.png"/>
<div class="caption">
Input waveforms generated by the generate_waveforms()-function (3 different shapes)</div></div>
<p>  Now the algorithm should work on this input data.<br/>
<br/>
 <b>Initialization phase:</b> </p>
<div class="image"><div class="image">
<img src="progress_0.png"  alt="progress_0.png" width=" 700"/>
</div>
<div class="caption"> Visualization of the algorithm at the initialization phase</div></div><div style="display: none;"><div class="image">
<img src="progress_0.png" alt="progress_0.png"/>
</div>
<p> "" </div>  <ul>
<li>
Upper part: <ul>
<li>
2D plot of the generated waveforms </li>
<li>
x-axis: time </li>
<li>
y-axis: potential </li>
<li>
color indicates the (actual) membership of a certain waveform to a cluster </li>
</ul>
</li>
<li>
Middle part: <ul>
<li>
2D plot of the given waveforms transformed into principal components </li>
<li>
x-axis: PC1 </li>
<li>
y-axis: PC2 </li>
<li>
color indicates the (actual) membership of a certain waveform to a cluster </li>
<li>
ellipses represent the (actual) parameters of the clusters (see figure below) </li>
</ul>
</li>
<li>
Lower part: <ul>
<li>
bar plot of the <img class="formulaInl" alt="$\pi$" src="form_98.png"/> values </li>
<li>
x-axis: j (number of respective cluster) </li>
<li>
y-axis: <img class="formulaInl" alt="$\pi$" src="form_98.png"/> value </li>
<li>
color indicates the (actual) cluster j </li>
</ul>
</li>
</ul>
<div class="image"><div class="image">
<img src="ellipse_details.png"  alt="ellipse_details.png" width=" 700"/>
</div>
<div class="caption"> Cluster parameters indicated by an ellipse</div></div><div style="display: none;"><div class="image">
<img src="ellipse_details.png" alt="ellipse_details.png"/>
</div>
<p> "" </div>  <ul>
<li>
points are the transformed waveforms <img class="formulaInl" alt="$x_i$" src="form_118.png"/> </li>
<li>
blue stars are the means of a ellipse j <img class="formulaInl" alt="$\mu_j$" src="form_152.png"/> </li>
<li>
the ellipse j is spanned by its semiaxis (computed of eigenvalues and eigenvectors of <img class="formulaInl" alt="$\Sigma_j$" src="form_153.png"/>) <img class="formulaInl" alt="$\Sigma_{j_x}, \Sigma_{j_y}$" src="form_154.png"/> </li>
<li>
ellipse j represents <img class="formulaInl" alt="$\Sigma_j$" src="form_153.png"/> </li>
</ul>
<p><b>Iteration:</b> </p>
<div class="image"><div class="image">
<img src="progress_1.png"  alt="progress_1.png" width=" 700"/>
</div>
<div class="caption"> Visualization of the algorithm in iteration phase (optimizing probability with given clusters)</div></div><div style="display: none;"><div class="image">
<img src="progress_1.png" alt="progress_1.png"/>
</div>
<p> "" </div>  <div class="image"><div class="image">
<img src="progress_2.png"  alt="progress_2.png" width=" 700"/>
</div>
<div class="caption"> Visualization of the algorithm in iteration phase (purging clusters with less points)</div></div><div style="display: none;"><div class="image">
<img src="progress_2.png" alt="progress_2.png"/>
</div>
<p> "" </div>  <div class="image"><div class="image">
<img src="progress_3.png"  alt="progress_3.png" width=" 700"/>
</div>
<div class="caption"> Visualization of the algorithm in iteration phase (clusters have been reduced to a small subset of high probability clusters)</div></div><div style="display: none;"><div class="image">
<img src="progress_3.png" alt="progress_3.png"/>
</div>
<p> "" </div>  <div class="image"><div class="image">
<img src="progress_4.png"  alt="progress_4.png" width=" 700"/>
</div>
<div class="caption"> Visualization of the algorithm in iteration phase (final result showing final classifications and parameters)</div></div><div style="display: none;"><div class="image">
<img src="progress_4.png" alt="progress_4.png"/>
</div>
<p> "" </div><p>  <b>Video:</b> </p>
<div class="image">
<img src="video.gif" alt="video.gif"/>
<div class="caption">
Visualization of the algorithm</div></div>
<p>  In order to produce the video after the algorithm was applied, the folloing steps are required: </p>
<ul>
<li>
while the algorithm is running several snapshots are generted by the dump() function in the "/plot" directory <ul>
<li>
plots in postscript are generated using gnuplot </li>
<li>
postscript files are converted into pdf (postscript removed) </li>
<li>
pdf files are rasterized to jpeg files which are copied several times (makes video slower) </li>
</ul>
</li>
<li>
to compile all the jpeg files into a video, use the following command: <pre>ffmpeg -i out%d.jpeg video.mpg</pre> </li>
<li>
the dump() function can be called on a abitrary step of the algorithm to show snapshots of interest (or disabled to ensure effiency) </li>
</ul>
<p><b>Simulation parameters:</b></p>
<p>The visualized simulation above was executed with the following parameters </p>
<pre></pre><pre># Listing of Parameters
# ---------------------
subsection Algorithmic parameter.
  # Maximal number of iterations.
  set Max iterations           = 50</pre><pre>  # cpu or gpu
  set Method                   = cpu</pre><pre>  # Number of openMP threads.
  set Number of openMP threads = 16
end</pre><pre>subsection Dimensions of test problems.
  # Binary logarithm of minimal number of columns of upper triangular matrix
  # R. Allowed range : [3,13]
  set log2(max n cols)   = 3</pre><pre>  # Binary logarithm of minimal number of columns of upper triangular matrix
  # R. Allowed range : [2,12]
  set log2(min n cols)   = 2</pre><pre>  # Repeat the test for a given matrix size this many times.
  set n repetitions      = 1</pre><pre>  # In each test instance the number of rows of R is increased by this factor.
  # Allowed range : [1.1,10]
  set n rows growth rate = 1.2
end</pre><pre>subsection Global parameters
  # double
  set Run Simulation double = false</pre><pre>  # Single precision
  set Run Simulation float  = true
end</pre><pre>subsection NIPALS parameters
  # Maximal number of iterations. If -1 is given termination of NIPALS
  # iterations solely depends on the given tolerance
  set Maximal number of iterations = 1000</pre><pre>  # Number of components
  set Number of components         = 2</pre><pre>  # Once the relative change of an eigenvalue in the inner power iteration is
  # les than the given value iteration stops and the next principal component
  # is computed.
  set Tolerance for eigenvalues    = 1e-5
end</pre><pre>subsection Problem parameter.
  # Cluster centers.
  set Cluster centers                   = (0,0),(3,0),(0,4),(5,5)</pre><pre>  # Initial Cluster centers.
  set Initial centers                   = (0,0),(1,1),(2,2),(3,3)</pre><pre>  # Number of clusters.
  set Number of clusters                = 20</pre><pre>  # Number of data points per cluster.
  set Number of data points per cluster = 1000</pre><pre>  # standard deviation for the normal distribution Allowed range : [0.,10.]
  set Sigma                             = 0.3</pre><pre>  # Corresponds to the number of the principal components one is looking for.
  set dimension                         = 2
end</pre><pre>subsection Program parameter.
  # input file for calculation
  set Input file    = bla.data</pre><pre>  # output folder location
  set Output folder = output
end</pre><pre>subsection Visualization flags.
  # Multiplying Q and R as obtained from the factorization should give
  # something that closely resembles the original A
  set print QR                     = false</pre><pre>  # Computing ||Q_orig - Q||_2 must be done column-wise as the individual
  # columns of Q are reproduced only up to a sign (the algorithm cannot
  # distinguish the direction of a column vector).
  set print Q column errors        = false
  set print Q from factorization   = false</pre><pre>  # Multiplying the Q obtained from the factorization with its own transpose
  # should give a unit matrix.
  set print QtQ from factorization = false
  set print R from factorization   = false</pre><pre>  # The original A is given multiplying the original Q with the original R.
  set print original A             = false
  set print original Q             = false
  set print original R             = false
end</pre><pre>subsection Waveforms parameters
  # Center 1 of Wave 3
  set Center 1 of Wave 3 = 0.6</pre><pre>  # Center 2 of Wave 3
  set Center 2 of Wave 3 = 0.65</pre><pre>  # Center of Wave 1
  set Center of Wave 1   = 0.25</pre><pre>  # Center of Wave 2
  set Center of Wave 2   = 0.85</pre><pre>  # Noise intensity
  set Noise intensity    = 0.2</pre><pre>  # Number of columns
  set Number of columns  = 128</pre><pre>  # Number of Waves
  set Number of waves    = 300,300,300</pre><pre>  # output folder location
  set Output folder      = output</pre><pre>  # Sigma 1 of Wave 3 (Lorenz)
  set Sigma 1 of Wave 3  = 0.05</pre><pre>  # Sigma 2 of Wave 3
  set Sigma 2 of Wave 3  = 0.06</pre><pre>  # Sigma of Wave 1 (standard deviation of gaussian)
  set Sigma of Wave 1    = 0.09
end</pre><pre></pre><p><b>Memory throughput:</b></p>
<p>The memory bandwidth and runtimes measurements of the implemented kernels are shown in the next figure. They are obtained on a Tesla C2070 graphic card. Denote that the maximal bandwidth of the hardware is 120 GB/s with 515 GFlop/s (double precision).</p>
<div class="image"><div class="image">
<img src="bandwidth.png"  alt="bandwidth.png" width=" 700"/>
</div>
<div class="caption"> red: processing power of kernels using normal operations, blue: processing power of kernels using "special function kernels" (SFUs), green: memory throughput of kernels.</div></div><div style="display: none;"><div class="image">
<img src="bandwidth.png" alt="bandwidth.png"/>
</div>
<p> "" </div> <p>Based on this results it can be obtained that the implemented algorithm is profitable due to the effective use of the graphic hardware bandwidth which is 5-10 times larger than the one of a CPU. The following table shows the runtimes of each kernel.</p>
<table class="doxtable">
<tr>
<th>Kernel</th><th>Time in ms </th></tr>
<tr>
<td>Subtract Array</td><td>1.24 </td></tr>
<tr>
<td>Matrix-Matrix Skalar</td><td>10 </td></tr>
<tr>
<td>Determinate</td><td>0.05 </td></tr>
<tr>
<td>Assemble P_ij</td><td>0.96 </td></tr>
<tr>
<td>Assemble u_ij</td><td>0.19 </td></tr>
<tr>
<td>Assemble z_ij</td><td>0.32 </td></tr>
<tr>
<td>Calculate y</td><td>0.38 </td></tr>
<tr>
<td>Sum Array</td><td>0.07 </td></tr>
<tr>
<td>Sum Array2D</td><td>0.41 </td></tr>
<tr>
<td>Matrix-Matrix Multiplikation</td><td>1.3 </td></tr>
<tr>
<td>SMX</td><td>1.26 </td></tr>
</table>
<p><a class="anchor" id="PlainProg"></a> </p>
<h1>The plain program</h1>
<p>(If you are looking at a locally installed CUDA HPC Praktikum version, then the program can be found at <em> .. /.. /testsite / /step-7 /step-cu.cc </em>. Otherwise, this is only the path on some remote server.) </p>
<div class="fragment"><pre class="fragment"> / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef WAVEFORMS_GENERATOR_H</span>
<span class="preprocessor"></span><span class="preprocessor"> #define WAVEFORMS_GENERATOR_H</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;time.h&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
<span class="preprocessor"> #include &lt;QDir&gt;</span>
<span class="preprocessor"> #include &lt;QString&gt;</span>
<span class="preprocessor"> #include &lt;QVector&gt;</span>
 
<span class="preprocessor"> #include &lt;boost/random/mersenne_twister.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/random/normal_distribution.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/random/variate_generator.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/random/uniform_real.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/math/distributions/students_t.hpp&gt;</span>
</pre></div><p> <a class="anchor" id="plain-ClassWaveForms"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>WaveForms{
 
 <span class="keyword">public</span>:
     WaveForms();
</pre></div><p> <a class="anchor" id="plain-Functiongenerate_waveforms"></a> </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
     <span class="keyword">static</span> <span class="keywordtype">void</span> generate_waveforms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row,
                                    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col,
                                    dealii::FullMatrix&lt;D&gt; &amp;waveforms,
                                    <span class="keyword">const</span> std::vector&lt;int&gt; &amp;n_waves,
                                    D S,
                                    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;waves_parameter)
     {
         boost::mt19937 rng;
         boost::uniform_real&lt;D&gt; u(-1., 1.);
         boost::variate_generator&lt;boost::mt19937&amp;, boost::uniform_real&lt;D&gt; &gt; gen(rng, u);
 
         boost::mt19937 rng2;
         boost::uniform_real&lt;D&gt; v(0., 1.);
         boost::variate_generator&lt;boost::mt19937&amp;, boost::uniform_real&lt;D&gt; &gt; gen2(rng2, v);
 
 
         <span class="keywordtype">double</span> form;
         <span class="keywordtype">int</span> form_id;
         <span class="keywordtype">double</span> X, X1, X2, sig, sig1, sig2, nu, t, Y, noise, l, t0;
         <span class="keywordtype">double</span> P0,P1,P2,P3,P4,P5,P6;
 
         P0 = waves_parameter[0];
         P1 = waves_parameter[1];
         P2 = waves_parameter[2];
         P3 = waves_parameter[3];
         P4 = waves_parameter[4];
         P5 = waves_parameter[5];
         P6 = waves_parameter[6];
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; row ; j++){
 
             form = gen2();
 
             <span class="keywordflow">if</span>(form&lt;(n_waves[0]/(<span class="keywordtype">double</span>)row))
                 form_id=1;
             <span class="keywordflow">else</span>{
                 <span class="keywordflow">if</span>(form &gt; ((n_waves[0]+n_waves[1])/(<span class="keywordtype">double</span>)row))
                     form_id = 3;
                 <span class="keywordflow">else</span>
                     form_id= 2;
             }
 
             <span class="keywordflow">switch</span>(form_id){
             <span class="keywordflow">case</span> 1:{
                 noise = 1+(gen()*S);
 
                 X = P0*(noise);
                 sig = P1*(noise);
                 t = 0.1*(noise);
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     Y = gen()*S;
                     l = k/double(col);
                     waveforms(j,k) = (1+Y)+(1/t)*((l-X)*exp(-(std::pow(((l-X)/(sig*sqrt(2))),2))));
                 }
                 <span class="keywordflow">break</span>;
             }
             <span class="keywordflow">case</span> 2:{
 
                 noise = (gen() * S);
                 t0 = P2*double(col);
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
 
                     t = 12;
                     <span class="keywordflow">if</span>(k &lt; t0-t/2 || k &gt; t0+t/2)
                         waveforms(j,k) = 0.0;
                     <span class="keywordflow">else</span>
                         waveforms(j,k) = (1 + noise) * std::pow(cos(((k - t0 + t * noise) / t) * M_PI), 2);
                     waveforms(j,k)   += gen() * S;
                 }
 
 
                 <span class="keywordflow">break</span>;
             }
             <span class="keywordflow">case</span> 3:{
 
                 noise = 1+(gen()*S)*0.5;
 
                 X1 = P3*noise;
                 sig1 = P5*noise;
                 t = noise;
                 X2 = P4*noise;
                 sig2 = P6*noise;
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     Y = gen()*S;
                     l = k/double(col);
                     waveforms(j,k) = (1+Y)+(1/t)*(((1/(1+std::pow(((l-X1)/sig1),2))) - (1/(1+std::pow(((l-X2)/sig2),2)))));
                 }
                 <span class="keywordflow">break</span>;
             }
             <span class="keywordflow">default</span>:{
                 std::cout&lt;&lt;<span class="stringliteral">&quot;illegal waveform choosen&quot;</span>&lt;&lt;std::endl;
             }
 
             }
         }
     }
</pre></div><p> <a class="anchor" id="plain-Functionnormalize_waveforms"></a> </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
     <span class="keyword">static</span> <span class="keywordtype">void</span> normalize_waveforms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_rows, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_cols,
                                     dealii::FullMatrix&lt;D&gt; &amp;waveforms)
     {
         <span class="keywordtype">double</span> row_sum, row_mean;
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n_rows; i++){
             row_sum = 0., row_mean = 1.;
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n_cols; j++){
                 row_sum += waveforms(i,j);
             }
             row_mean = row_sum/(double)n_cols;
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n_cols; j++){
                 waveforms(i,j) -= row_mean;
             }
         }
     }
</pre></div><p> <a class="anchor" id="plain-Functionoriginal_waveforms"></a> </p>
<div class="fragment"><pre class="fragment">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> D&gt;
     <span class="keyword">static</span> <span class="keywordtype">void</span> original_waveforms(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col, <span class="keywordtype">int</span> n_forms,
                                    dealii::FullMatrix&lt;D&gt; &amp;check_waves,
                                    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;waves_parameter,
                                    <span class="keyword">const</span> std::vector&lt;int&gt; &amp;n_waves)
     {
         <span class="keywordtype">double</span> X, X1, X2, sig, sig1, sig2, nu, t, noise, l;
         <span class="keywordtype">double</span> P0,P1,P2,P3,P4,P5,P6;
 
         P0 = waves_parameter[0];
         P1 = waves_parameter[1];
         P2 = waves_parameter[2];
         P3 = waves_parameter[3];
         P4 = waves_parameter[4];
         P5 = waves_parameter[5];
         P6 = waves_parameter[6];
 
         <span class="keywordtype">int</span> w1, w2, w3;
 
         w1 = n_waves[0];
         w2 = n_waves[1];
         w3 = n_waves[2];
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n_forms;i++){
             <span class="keywordflow">if</span>(w1!= 0 &amp;&amp; i&lt;n_forms){
                 X = P0;
                 sig = P1;
                 t = 0.1;
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     l = k/double(col);
                     check_waves(i,k) = (1/t)*((l-X)*exp(-(std::pow(((l-X)/(sig*sqrt(2))),2))));
                 }
                 w1 = 0;
                 i ++;
             }
             <span class="keywordflow">if</span>(w2!=0 &amp;&amp; i&lt;n_forms){
 
                 nu = P2;
                 X = (1/(nu*2));
                 l= 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     l = k/double(col) + noise;
                     <span class="keywordflow">if</span>(l &gt; 2*X|| l &lt; 0 ){
                         check_waves(i,k) = 0.;
                     }<span class="keywordflow">else</span>{
                         check_waves(i,k) = std::pow(sin(nu*M_PI*l),2);
                     }
                 }
                 w2 =0;
                 i++;
             }
             <span class="keywordflow">if</span>(w3!=0 &amp;&amp; i&lt;n_forms){
 
                 X1 = P3;
                 sig1 = P5;
                 X2 = P4;
                 sig2 = P6;
                 l = 0.;
 
                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k&lt;col; k++){
                     l = k/double(col);
                     check_waves(i,k) = (((1/(1+std::pow(((l-X1)/sig1),2))) - (1/(1+std::pow(((l-X2)/sig2),2)))));
                 }
                 w3 = 0;
                 i++;
             }
         }
     }
 };
 
 
<span class="preprocessor"> #endif // WAVEFORMS_GENERATOR_H</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef CUDA_KERNEL_STEP_7_CU_H</span>
<span class="preprocessor"> #define CUDA_KERNEL_STEP_7_CU_H</span>
</pre></div><p> <a class="anchor" id="plain-Declarationsofthekernelwrapperfunctions"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 <span class="keyword">struct </span>Kernel {
 
     <span class="keywordtype">void</span> subtract_array_from_matrix(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> g,
                                     <span class="keyword">const</span> T * X,
                                     <span class="keyword">const</span> T * mu_j,
                                     T * M);
 
     <span class="keywordtype">void</span> MM_scalar(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                    <span class="keyword">const</span> T * A,
                    <span class="keyword">const</span> T * B,
                    T * result);
 
     T Det(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> MS, <span class="keyword">const</span> T * A);
 
 
 
     <span class="keywordtype">void</span> assemble_P_ij(T gamma,
                        T v,
                        <span class="keywordtype">int</span> p,<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * Delta,
                        <span class="keyword">const</span> T * delta,
                        T * P_ij);
 
 
     <span class="keywordtype">void</span> assemble_u_ij(T v,
                        <span class="keywordtype">int</span> p,<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * delta,
                        T * u_ij);
 
     <span class="keywordtype">void</span> assemble_z_ij(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * P_ij,
                        <span class="keyword">const</span> T * c,
                        <span class="keyword">const</span> T * pi,
                        T * z_ij);
 
     <span class="keywordtype">void</span> reduce(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n,
                 <span class="keyword">const</span> T * c,
                 T * result,
                 <span class="keywordtype">int</span> threads,
                 <span class="keywordtype">int</span> blocks);
 
     <span class="keywordtype">double</span> calculate_y(<span class="keywordtype">int</span> n,
                        <span class="keywordtype">int</span> g,
                        T v,
                        T digamma,
                        <span class="keyword">const</span> T * z_ij,
                        <span class="keyword">const</span> T * delta_ij,
                        <span class="keyword">const</span> T * u_ij);
 
     <span class="keywordtype">double</span> sum_array(<span class="keywordtype">int</span> n,
                      <span class="keyword">const</span> T * input,
                      <span class="keywordtype">bool</span> log);
 
     <span class="keywordtype">void</span> sum_matrix_cols(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * input,
                          T * output,
                          <span class="keywordtype">bool</span> log);
 
     <span class="keywordtype">double</span> sum_array(<span class="keywordtype">int</span> n,
                      <span class="keywordtype">int</span> g,
                      <span class="keyword">const</span> T * input,
                      <span class="keywordtype">bool</span> log);
 
     <span class="keywordtype">void</span> sum_array2D(<span class="keywordtype">int</span> n,
                      <span class="keywordtype">int</span> g,
                      <span class="keyword">const</span> T * z_ij,
                      <span class="keyword">const</span> T * u_ij,
                      T * output);
 
     <span class="keywordtype">void</span> MxM(<span class="keywordtype">int</span> n,<span class="keywordtype">int</span> g,
              <span class="keyword">const</span> T * z_ij,
              <span class="keyword">const</span> T * u_ij,
              T * q_ij);
 
     <span class="keywordtype">void</span> SMX(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
              <span class="keyword">const</span> T * q_ij,
              <span class="keyword">const</span> T C_j,
              <span class="keyword">const</span> <span class="keywordtype">int</span> j,
              <span class="keyword">const</span> T * X,
              <span class="keyword">const</span> T * mu_j,
              T * M);
 
 };
 
<span class="preprocessor"> #endif // CUDA_KERNEL_STEP_7_CU_H</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #include &lt;step-7/cuda_kernel_wrapper_step-7.cu.h&gt;</span>
 
<span class="preprocessor"> #include &lt;math.h&gt;</span>
<span class="preprocessor"> #include &lt;stdio.h&gt;</span>
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
 
 <span class="keywordtype">float</span> Giga_bytes = std::pow(1024.,3);
 
 cudaEvent_t beginEvent;
 cudaEvent_t endEvent;
 
 std::ofstream dt(<span class="stringliteral">&quot;output/Memory_Bandwidth.txt&quot;</span>);
</pre></div><p> <a class="anchor" id="plain-Kernel__subtract_array_from_matrix"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __subtract_array_from_matrix(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> g,
                                              <span class="keyword">const</span> T * X,
                                              <span class="keyword">const</span> T * mu_j,
                                              T * M)
 {
     <span class="keywordtype">int</span> r = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> c = blockIdx.x;
 
     <span class="keywordflow">if</span>(r &lt; n &amp;&amp; c &lt; p){
         M[c*n+r] = X[c*n+r]-mu_j[j+c*g];
     }
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__MM_scalar"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __MM_scalar(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                             <span class="keyword">const</span> T * A,
                             <span class="keyword">const</span> T * B,
                             T * result)
 {
     <span class="keywordtype">int</span> r = blockIdx.x * blockDim.x + threadIdx.x;
 
     T sum = 0.;
 
     <span class="keywordflow">if</span>(r &lt; n){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j= 0; j&lt;p; j++){
             sum += A[j*n+r]*B[r*p+j];
         }
         result[r] = sum;
     }
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__Det"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __Det(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> MS,
                       <span class="keyword">const</span> T * A,
                       T * result)
 {
     T det = 1.;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;p; i++){
         det *= A[i*MS+i];
     }
 
     *result = det;
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__P_ij"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __P_ij(T gamma,
                        T v,
                        <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * Delta,
                        <span class="keyword">const</span> T * delta,
                        T * P_ij)
 {
     <span class="keywordtype">int</span> i = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         P_ij[j*n+i] = gamma/Delta[j]/(pow((1.+delta[j*n+i]/v),(v+p)/2.));
     }
 
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__u_ij"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __u_ij(T v,
                        <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * delta,
                        T * u_ij)
 {
     <span class="keywordtype">int</span> i = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         u_ij[j*n+i] = (p+2)/(delta[j*n+i]+v);
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__z_ij"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __z_ij(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * P_ij,
                        <span class="keyword">const</span> T * c,
                        <span class="keyword">const</span> T * pi,
                        T * z_ij)
 {
     __shared__ T cs[512];
     __shared__ T pi_s[32];
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
     <span class="keywordtype">int</span> j = threadIdx.y;
 
 
     <span class="keywordflow">if</span> (j == 0){
         cs[threadIdx.x] = c[i];
     }
 
     <span class="keywordflow">if</span>(threadIdx.x &lt; g &amp;&amp; j == 0){
         pi_s[threadIdx.x] = pi[threadIdx.x];
     }
 
     __syncthreads();
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         z_ij[j*n+i] = (P_ij[j*n+i]*pi_s[j])/cs[threadIdx.x];
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionreduction"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 __device__ <span class="keywordtype">void</span> reduction(<span class="keyword">volatile</span> T * sum, <span class="keywordtype">int</span> tid)
 {
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = blockDim.x/2; k&gt;0; k/=2){
         <span class="keywordflow">if</span>(tid &lt; k){
             sum[tid] += sum[tid + k];
         }
         __syncthreads();
     }
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__sum_array"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __sum_array(<span class="keywordtype">int</span> n,
                             <span class="keyword">const</span> T * input,
                             T * result)
 {
     __shared__ T sum[512];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     sum[threadIdx.x] += input[i];
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         result[blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__sum_log_array"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __sum_log_array(<span class="keywordtype">int</span> n,
                                 <span class="keyword">const</span> T * input,
                                 T * result)
 {
     __shared__ T sum[512];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     sum[threadIdx.x] += log(input[i]);
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         result[blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__sum_array2D"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __sum_array2D(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                               <span class="keyword">const</span> T * z_ij,
                               <span class="keyword">const</span> T * u_ij,
                               T * output)
 {
     __shared__ T sum[512];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.y;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     <span class="keywordtype">int</span> global_index = j*n+i;
     sum[threadIdx.x] += z_ij[global_index]* u_ij[global_index];
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         output[blockIdx.y*gridDim.x+blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__y"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __y(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g, T v, T digamma,
                     <span class="keyword">const</span> T * z_ij,
                     <span class="keyword">const</span> T * delta_ij,
                     <span class="keyword">const</span> T * u_ij,
                     T * results)
 {
     __shared__ T sum[256];
 
     sum[threadIdx.x] = 0.;
     __syncthreads();
 
 
     <span class="keywordtype">int</span> i = threadIdx.x + blockDim.x * blockIdx.x;
 
     <span class="keywordflow">if</span>(i&gt;=n)
         <span class="keywordflow">return</span>;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         <span class="keywordtype">int</span> global_index = j*n+i;
         sum[threadIdx.x] += z_ij[global_index]*(digamma+log(2/(delta_ij[global_index]+v))-u_ij[global_index]);
     }
     __syncthreads();
 
     reduction(sum, threadIdx.x);
 
     <span class="keywordflow">if</span>(threadIdx.x == 0){
         results[blockIdx.x]= sum[0];
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__MxM"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __MxM(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                       <span class="keyword">const</span> T * z_ij,
                       <span class="keyword">const</span> T * u_ij,
                       T * q_ij)
 {
     <span class="keywordtype">int</span> i = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> j = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(i &lt; n &amp;&amp; j &lt; g){
         q_ij[j*n+i] = z_ij[j*n+i]*u_ij[j*n+i];
     }
 }
</pre></div><p> <a class="anchor" id="plain-Kernel__SMX"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
 __global__ <span class="keywordtype">void</span> __SMX(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                       <span class="keyword">const</span> T * q_ij,
                       <span class="keyword">const</span> T inv_C_j,
                       <span class="keyword">const</span> <span class="keywordtype">int</span> j,
                       <span class="keyword">const</span> T * X,
                       <span class="keyword">const</span> T * mu_j,
                       T * M)
 {
     <span class="keywordtype">int</span> r = blockIdx.y * blockDim.x + threadIdx.x;
     <span class="keywordtype">int</span> c = blockIdx.x;
 
 
     <span class="keywordflow">if</span>(r &lt; n &amp;&amp; c &lt; p){
         M[c*n+r] = (X[c*n+r]-mu_j[c]) * sqrt(q_ij[j*n+r] * inv_C_j);
     }
 }
</pre></div><p> <a class="anchor" id="plain-Functionsubtract_array_from_matrix"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> Kernel&lt;T&gt;::subtract_array_from_matrix(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> g,
                                            <span class="keyword">const</span> T * X,
                                            <span class="keyword">const</span> T * mu_j,
                                            T * M)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(p, gridDim_y);
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 1;
     <span class="keywordtype">int</span> n_memory_access = 3;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     dt &lt;&lt;<span class="stringliteral">&quot;Kernel name&quot;</span>
       &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
      &lt;&lt;<span class="stringliteral">&quot;Time in Milliseconds&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;\t\t&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;bandwidth in GB/s&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;\t\t&quot;</span>
     &lt;&lt;<span class="stringliteral">&quot;Gflops/Second&quot;</span>
     &lt;&lt; std::endl;
     dt &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------------------------------------------------------------------&quot;</span>
        &lt;&lt;std::endl;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s &lt; N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __subtract_array_from_matrix&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, p, j, g,
                                                                  X,
                                                                  mu_j,
                                                                  M);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;subtract_kernel:::::&quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/ Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p> <a class="anchor" id="plain-FunctionMM_scalar"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> Kernel&lt;T&gt;::MM_scalar(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                           <span class="keyword">const</span> T * A,
                           <span class="keyword">const</span> T * B,
                           T * output)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">long</span> n_operations = 2*p;
     <span class="keywordtype">int</span> n_memory_access = 2*p+1;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
         __MM_scalar&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, p,
                                                 A,
                                                 B,
                                                 output);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
     }
 
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;MM_scalar:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*p)*n_operations)/(time_sum/1000)/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 }
</pre></div><p> <a class="anchor" id="plain-FunctionDet"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 T
 Kernel&lt;T&gt;::Det(<span class="keywordtype">int</span> p, <span class="keywordtype">int</span> MS, <span class="keyword">const</span> T * A)
 {
     <span class="keywordtype">int</span> block_size = 1;
     <span class="keywordtype">int</span> num_blocks = 1;
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = p;
     <span class="keywordtype">int</span> n_memory_access = p+1;
 
 
     T det;
     T * det_d;
     cudaMalloc(&amp;det_d, <span class="keyword">sizeof</span>(T));
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __Det&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(p, MS, A, det_d);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;Det_Kernel:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((p*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((p*p*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(&amp;det, det_d,
                <span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     cudaFree(det_d);
 
     <span class="keywordflow">return</span> det;
 }
</pre></div><p> <a class="anchor" id="plain-Functionassemble_P_ij"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::assemble_P_ij(T gamma,
                          T v,
                          <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * Delta,
                          <span class="keyword">const</span> T * delta,
                          T * P_ij)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(g, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 4;
     <span class="keywordtype">int</span> n_memory_access = 3;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
 
         __P_ij&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(gamma,
                                            v,
                                            p, n, g,
                                            Delta,
                                            delta,
                                            P_ij);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;assemble_P_ij:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionassemble_u_ij"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::assemble_u_ij(T v,
                          <span class="keywordtype">int</span> p, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * delta,
                          T * u_ij)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(g, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 2;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __u_ij&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(v,
                                            p, n, g,
                                            delta,
                                            u_ij);
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;assemble_u_ij:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionassemble_z_ij"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::assemble_z_ij(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                          <span class="keyword">const</span> T * P_ij,
                          <span class="keyword">const</span> T * c,
                          <span class="keyword">const</span> T * pi,
                          T * z_ij)
 {
     <span class="keywordtype">int</span> blockDim_x = max(16/g, 1) * 32;
     dim3 block_size(blockDim_x,g);
     <span class="keywordtype">int</span> num_blocks = (n+blockDim_x-1)/blockDim_x;
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 2;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
         __z_ij&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, g,
                                            P_ij,
                                            c,
                                            pi,
                                            z_ij);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;assemble_z_ij:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; ((((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)+n+g)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p> <a class="anchor" id="plain-Functioncalculate_y"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">double</span>
 Kernel&lt;T&gt;::calculate_y(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g, T v, T digamma,
                        <span class="keyword">const</span> T * z_ij,
                        <span class="keyword">const</span> T * delta_ij,
                        <span class="keyword">const</span> T * u_ij)
 {
     <span class="keywordtype">int</span> block_size = 256;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
     T y;
 
     T * results_h = <span class="keyword">new</span> T[num_blocks];
     T * results_d;
     cudaMalloc(&amp;results_d, num_blocks*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 6*g + sqrt(block_size/2)+1;
     <span class="keywordtype">int</span> n_memory_access = 4;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __y&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, g, v, digamma,
                                         z_ij,
                                         delta_ij,
                                         u_ij,
                                         results_d);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;calculate_y:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                num_blocks*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_blocks; i++){
         y += results_h[i];
     }
 
     <span class="keywordflow">return</span> y;
 }
</pre></div><p> <a class="anchor" id="plain-Functionsum_array"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">double</span>
 Kernel&lt;T&gt;::sum_array(<span class="keywordtype">int</span> n,
                      <span class="keyword">const</span> T * input,
                      <span class="keywordtype">bool</span> log)
 {
     <span class="keywordtype">double</span> result = 0.;
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
 
     T * results_h = <span class="keyword">new</span> T[num_blocks];
     T * results_d;
     cudaMalloc(&amp;results_d, num_blocks*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = sqrt(block_size/2)+1+1;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         <span class="keywordflow">if</span>(log){
             __sum_log_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input,results_d);
         }<span class="keywordflow">else</span>{
             __sum_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input,results_d);
         }
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;sum_array:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                num_blocks*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_blocks; i++){
         result += results_h[i];
     }
 
     <span class="keywordflow">return</span> result;
 }
</pre></div><p> <a class="anchor" id="plain-Functionsum_matrix_cols"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::sum_matrix_cols(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                            <span class="keyword">const</span> T * input,
                            T * output,
                            <span class="keywordtype">bool</span> log)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> num_blocks = (n+block_size-1)/block_size;
 
 
     T * results_h = <span class="keyword">new</span> T[num_blocks*g];
     T * results_d;
     cudaMalloc(&amp;results_d, num_blocks*g*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0;j &lt; g; j++){
         <span class="keywordflow">if</span>(log){
             __sum_log_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input+(n*j),results_d+(j*num_blocks));
         }<span class="keywordflow">else</span>{
             __sum_array&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,input+(n*j),results_d+(j*num_blocks));
         }
     }
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                num_blocks*g*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_blocks; i++){
             output[j] += results_h[i+j*num_blocks];
         }
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionsum_array2D"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::sum_array2D(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                        <span class="keyword">const</span> T * z_ij,
                        <span class="keyword">const</span> T * u_ij,
                        T * output)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_x = ((n+block_size-1)/block_size);
     dim3 num_blocks (gridDim_x, g);
 
 
     T * results_h = <span class="keyword">new</span> T[gridDim_x*g];
     T * results_d;
     cudaMalloc(&amp;results_d, gridDim_x*g*<span class="keyword">sizeof</span>(T));
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 2 + sqrt(block_size/2)+1;
     <span class="keywordtype">int</span> n_memory_access = 2;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __sum_array2D&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n,g,z_ij, u_ij,results_d);
 
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;sum_array2D:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
     cudaThreadSynchronize();
 
     cudaMemcpy(results_h, results_d,
                gridDim_x*g*<span class="keyword">sizeof</span>(T), cudaMemcpyDeviceToHost);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;g; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j= 0; j&lt;gridDim_x; j++){
             output[i] += results_h[i*gridDim_x+j];
         }
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-FunctionMxM"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::MxM(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> g,
                <span class="keyword">const</span> T * z_ij,
                <span class="keyword">const</span> T * u_ij,
                T * q_ij)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(g, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 1;
     <span class="keywordtype">int</span> n_memory_access = 3;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __MxM&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, g,
                                           z_ij,
                                           u_ij,
                                           q_ij);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;MxM_Kernel:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*g*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*g*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
</pre></div><p> <a class="anchor" id="plain-FunctionSMX"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span>
 Kernel&lt;T&gt;::SMX(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> p,
                <span class="keyword">const</span> T * q_ij,
                <span class="keyword">const</span> T C_j,
                <span class="keyword">const</span> <span class="keywordtype">int</span> j,
                <span class="keyword">const</span> T * X,
                <span class="keyword">const</span> T * mu_j,
                T * M)
 {
     <span class="keywordtype">int</span> block_size = 512;
     <span class="keywordtype">int</span> gridDim_y = (n+block_size-1)/block_size;
 
     dim3 num_blocks(p, gridDim_y);
 
 
     <span class="keywordtype">double</span> time_sum = 0;
     <span class="keywordtype">int</span> n_operations = 4;
     <span class="keywordtype">int</span> n_memory_access = 5;
 
     cudaEventCreate(&amp;beginEvent);
     cudaEventCreate(&amp;endEvent);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> s = 0; s&lt;N_REPS; s++){
 
         cudaEventRecord(beginEvent,0);
 
         __SMX&lt;&lt;&lt;num_blocks, block_size&gt;&gt;&gt;(n, p,
                                           q_ij,
                                           T(1./C_j),
                                           j,
                                           X,
                                           mu_j,
                                           M);
         cudaThreadSynchronize();
 
         cudaEventRecord(endEvent,0);
 
         cudaEventSynchronize(endEvent);
 
         <span class="keywordtype">float</span> timeValue;
         cudaEventElapsedTime(&amp;timeValue, beginEvent, endEvent);
         time_sum += timeValue;
 
 
     }
     time_sum /= N_REPS;
     dt &lt;&lt; <span class="stringliteral">&quot;SMX_Kernel:::::  &quot;</span>
        &lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span>
       &lt;&lt; time_sum
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Memory bandwidth: &quot;</span>
       &lt;&lt; (((n*p*<span class="keyword">sizeof</span>(T))*n_memory_access)/(time_sum/1000))/Giga_bytes
       &lt;&lt; <span class="stringliteral">&quot;\t\t&quot;</span>
       &lt;&lt; <span class="stringliteral">&quot;Gflops: &quot;</span>
       &lt;&lt; ((n*p*n_operations)/(time_sum/1000))/Giga_bytes
       &lt;&lt; std::endl;
 
     cudaEventDestroy(beginEvent);
     cudaEventDestroy(endEvent);
 
 }
 
 <span class="keyword">template</span> <span class="keyword">class </span>Kernel&lt;float&gt;;
 
<span class="preprocessor"> #ifndef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span> <span class="keyword">template</span> <span class="keyword">class </span>Kernel&lt;double&gt;;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef CUDADriver_STEP_7_H</span>
<span class="preprocessor"></span><span class="preprocessor"> #define CUDADriver_STEP_7_H</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #include &lt;deal.II/base/parameter_handler.h&gt;</span>
 
<span class="preprocessor"> #include &lt;lac/blas++.h&gt;</span>
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;step-6/cuda_driver_step-6.h&gt;</span>
<span class="preprocessor"> #include &lt;step-6/cuda_driver_step-6.hh&gt;</span>
<span class="preprocessor"> #include &lt;step-6/Kmeans.h&gt;</span>
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
<span class="preprocessor"> #include &lt;step-7/cuda_kernel_wrapper_step-7.cu.h&gt;</span>
 
 <span class="keyword">namespace </span>step7 {
</pre></div><p> <a class="anchor" id="plain-ClassShohamEM"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">class </span>ShohamEM : <span class="keyword">public</span> Kernel&lt;T&gt; {
 <span class="keyword">public</span>:
 <span class="keyword">public</span>:
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::blas_wrapper_type  BW;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix             Matrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix          SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol       MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubRow       MatrixSubRow;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubColVector SubColVector;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubRowVector SubRowVector;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector             Vector;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;                    tr;
     <span class="keyword">typedef</span>          transpose&lt;SubMatrix&gt;                 trSub;
 
     Matrix mu;
     <span class="keywordtype">int</span> g;
     <span class="keywordtype">int</span> g_min;
     std::vector&lt;T&gt; pi;
     std::vector&lt;Matrix&gt; Sigma;
     T v;
     <span class="keywordtype">double</span> L;
     <span class="keywordtype">double</span> L_max;
     <span class="keywordtype">double</span> N;
     <span class="keywordtype">int</span> p;
     Matrix u_ij;
     Matrix z_ij;
     Matrix P_ij;
 
     Matrix data;
     Matrix mean;
     <span class="keywordtype">int</span> n_data_points;
     Matrix delta_ij;
     std::vector&lt;Matrix&gt; Sigma_inv;
     T gamma;
     Vector Delta;
     std::vector&lt;Matrix&gt; Sigma_dec;
     Vector pi_d;
     Matrix M;
     <span class="keywordtype">int</span> iter;
 
     std::vector&lt;T&gt; pi_opt;
     Matrix mu_opt;
     std::vector&lt;Matrix&gt; Sigma_opt;
     T v_opt;
     Matrix u_ij_opt;
     Matrix z_ij_opt;
     Matrix P_ij_opt;
 
     <span class="keywordtype">int</span> it;
 
     ShohamEM(FullMatrixAccessor &amp;ddata, FullMatrixAccessor &amp;mmeans);
 
     <span class="keywordtype">void</span> dump();
 
     <span class="keywordtype">void</span> run_Shoham();
     <span class="keywordtype">void</span> initialize_Shoham();
     <span class="keywordtype">void</span> e_step_Shoham();
     <span class="keywordtype">void</span> m_step_Shoham();
     <span class="keywordtype">void</span> purge_step_Shoham();
 
     ~ShohamEM();
 
 };
</pre></div><p> <a class="anchor" id="plain-ClassKernelTest"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">class </span>KernelTest : <span class="keyword">public</span> Kernel&lt;T&gt; {
 <span class="keyword">public</span>:
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::blas_wrapper_type  BW;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix             Matrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix          SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol       MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubRow       MatrixSubRow;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector             Vector;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;              tr;
     <span class="keyword">typedef</span>          transpose&lt;SubMatrix&gt;              trSub;
 
 
     KernelTest(<span class="keywordtype">int</span> n_data_points, <span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> n_clusters);
 
     <span class="keywordtype">int</span> n_data_points, n_clusters, dim;
 
     <span class="keywordtype">void</span> run();
 
     ~KernelTest();
 };
 
 } <span class="comment">// namespace step7 END</span>
 
<span class="preprocessor"> #endif // CUDADriver_STEP_7_H</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #ifndef CUDA_DRIVER_STEP_7_HH</span>
<span class="preprocessor"></span><span class="preprocessor"> #define CUDA_DRIVER_STEP_7_HH</span>
<span class="preprocessor"></span><span class="preprocessor"> #include &lt;cuda_driver_step-7.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_kernel_wrapper_step-7.cu.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_kernel_wrapper_step-1.cu.h&gt;</span>
 
<span class="preprocessor"> #include &lt;base/CUDATimer.h&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/base/timer.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cmath&gt;</span>
<span class="preprocessor"> #include &lt;limits&gt;</span>
 
<span class="preprocessor"> #include &lt;lac/cublas_wrapper.hh&gt;</span>
 
<span class="preprocessor"> #include &lt;boost/math/special_functions/digamma.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/math/special_functions/erf.hpp&gt;</span>
<span class="preprocessor"> #include &lt;boost/math/special_functions/beta.hpp&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/numerics/histogram.h&gt;</span>
 
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
 
<span class="preprocessor"> #include &lt;QTime&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/base/convergence_table.h&gt;</span>
<span class="preprocessor"> #include &lt;deal.II/base/table_handler.h&gt;</span>
<span class="preprocessor"> #include &lt;deal.II/base/timer.h&gt;</span>
 
<span class="preprocessor"> #include &lt;fstream&gt;</span>
</pre></div><p> <a class="anchor" id="plain-StructRightMSolve"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">struct </span>RightMSolve{
 
     <span class="keyword">typedef</span> bw_types::SubMatrixView&lt;T, blas&gt; SubMatrix;
 
     <span class="keyword">const</span> SubMatrix &amp;l;
     SubMatrix &amp;r;
 
     RightMSolve(<span class="keyword">const</span> SubMatrix &amp; _l, SubMatrix &amp; _r):l(_l),r(_r){}
</pre></div><p> <a class="anchor" id="plain-Operator"></a> </p>
<div class="fragment"><pre class="fragment">     RightMSolve&lt;T, blas&gt; &amp; operator = (<span class="keyword">const</span> SubMatrix &amp; rhs)
     {
         r = rhs.matrix();
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;? X : AX = B &quot;</span> &lt;&lt; std::endl;
         <span class="keywordtype">char</span> side = <span class="charliteral">&#39;L&#39;</span>, uplo = <span class="charliteral">&#39;U&#39;</span>, transa = <span class="charliteral">&#39;N&#39;</span>, diag = <span class="charliteral">&#39;N&#39;</span>;
         <span class="keywordtype">int</span> m = rhs.r_end() - rhs.r_begin();
         <span class="keywordtype">int</span> n = rhs.c_end() - rhs.c_begin();
 
         T alpha = 1.0;
 
         <span class="keyword">const</span> T * <span class="keyword">const</span> A = l.val();
         <span class="keywordtype">int</span> lda = l.leading_dim();
 
         T *  B = r.val();
         <span class="keywordtype">int</span> ldb = r.leading_dim();
         blas::trsm(  side, uplo, transa, diag,
                      m, n, alpha,
                      A, lda, B, ldb     );
 
         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
     }
 
 };
</pre></div><p> <a class="anchor" id="plain-StructRightMSolveTr"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">struct </span>RightMSolveTr{
 
     <span class="keyword">typedef</span> bw_types::SubMatrixView&lt;T, blas&gt; SubMatrix;
     <span class="keyword">typedef</span>          transpose&lt;SubMatrix&gt;           tr;
 
     <span class="keyword">const</span> SubMatrix &amp;l;
     SubMatrix &amp;r;
 
     RightMSolveTr(<span class="keyword">const</span> tr &amp; _l, SubMatrix &amp; _r):l(_l.A),r(_r){}
</pre></div><p> <a class="anchor" id="plain-Operator"></a> </p>
<div class="fragment"><pre class="fragment">     RightMSolveTr&lt;T, blas&gt; &amp; operator = (<span class="keyword">const</span> SubMatrix &amp; rhs)
 
     {
 
         r = rhs.matrix();
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;? X : A^TX = B &quot;</span> &lt;&lt; std::endl;
         <span class="keywordtype">char</span> side = <span class="charliteral">&#39;L&#39;</span>, uplo = <span class="charliteral">&#39;U&#39;</span>, transa = <span class="charliteral">&#39;T&#39;</span>, diag = <span class="charliteral">&#39;N&#39;</span>;
         <span class="keywordtype">int</span> m = rhs.r_end() - rhs.r_begin();
         <span class="keywordtype">int</span> n = rhs.c_end() - rhs.c_begin();
 
         T alpha = 1.0;
 
         <span class="keyword">const</span> T * <span class="keyword">const</span> A = l.val();
         <span class="keywordtype">int</span> lda = l.leading_dim();
 
         T * B = r.val();
         <span class="keywordtype">int</span> ldb = r.leading_dim();
         cublas::trsm(  side, uplo, transa, diag,
                        m, n, alpha,
                        A, lda, B, ldb     );
 
         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
     }
 
 };
</pre></div><p> <a class="anchor" id="plain-Operator"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">inline</span> RightMSolve&lt;T, blas&gt;  operator * (<span class="keyword">const</span> bw_types::SubMatrixView&lt;T, blas&gt; &amp;l, bw_types::SubMatrixView&lt;T, blas&gt; &amp; r){
     <span class="keywordflow">return</span> RightMSolve&lt;T, blas&gt;(l,r);
 }
</pre></div><p> <a class="anchor" id="plain-Operator"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keyword">inline</span> RightMSolveTr&lt;T, blas&gt;  operator * (<span class="keyword">const</span> <span class="keyword">typename</span> RightMSolveTr&lt;T, blas&gt;::tr  &amp;l,
                                            bw_types::SubMatrixView&lt;T, blas&gt; &amp; r){
     <span class="keywordflow">return</span> RightMSolveTr&lt;T, blas&gt;(l,r);
 }
</pre></div><p> <a class="anchor" id="plain-ConstructorShohamEM"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::ShohamEM&lt;T, blas&gt;::ShohamEM(FullMatrixAccessor &amp;ddata, FullMatrixAccessor &amp;mmeans)
     :
       n_data_points(ddata.n_rows()), p(ddata.n_cols()),
       g(mmeans.n_rows()), data(ddata.n_rows(), ddata.n_cols())
 {
     BW::Init();
     data = ddata;
     mean = mmeans;
 }
</pre></div><p> <a class="anchor" id="plain-Functiondump"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T,blas&gt;::dump()
 {
 
 
     std::fstream em;
     em.open(<span class="stringliteral">&quot;output/em.dat&quot;</span>, std::ios::out);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; mu.n_rows(); i++){
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; mu.n_cols(); j++)
             em &lt;&lt; mu(i, j) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
 
         em &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
     }
 
     em.close();
 
 
     std::fstream piout;
     piout.open(<span class="stringliteral">&quot;output/pi.dat&quot;</span>, std::ios::out);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pi.size(); i++)
         piout &lt;&lt; pi[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
     piout.close();
 
 
     std::fstream ellipse;
     ellipse.open(<span class="stringliteral">&quot;output/ellipses.dat&quot;</span>, std::ios::out);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; g; k++){
 
         <span class="keywordtype">double</span> d;
         <span class="keywordtype">double</span> eig[2], eigv[2];
         <span class="keywordtype">int</span> perm[2];
 
         d = (Sigma[k](0, 0) - Sigma[k](1, 1)) / 2;
 
         eig[0] = (Sigma[k](0, 0) + Sigma[k](1, 1)) / 2 + sqrt(d * d + Sigma[k](0, 1) * Sigma[k](1, 0));
         eig[1] = (Sigma[k](0, 0) + Sigma[k](1, 1)) / 2 - sqrt(d * d + Sigma[k](0, 1) * Sigma[k](1, 0));
 
         <span class="keywordflow">if</span>(eig[0] &gt; eig[1] || <span class="keyword">true</span>){
             perm[0] = 0;
             perm[1] = 1;
         }
         <span class="keywordflow">else</span>{
             perm[0] = 1;
             perm[1] = 0;
         }
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;\nEig: &quot;</span> &lt;&lt; eig[perm[0]] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
         eigv[0] = eig[perm[0]] - Sigma[k](1, 1);
         eigv[1] = Sigma[k](1, 0);
 
         std::cout &lt;&lt; <span class="stringliteral">&quot;Eigv: &quot;</span> &lt;&lt; eigv[0] / sqrt(eigv[0] * eigv[0] + eigv[1] * eigv[1]) &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt; perm[0] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
         ellipse &lt;&lt; mu(k, 0) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; mu(k, 1) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; / *sqrt(* /sqrt(sqrt(eig[perm[0]]))/ *)* / &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; sqrt(sqrt(sqrt(eig[perm[1]])))
                 &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt;  acos(eigv[0] / sqrt(eigv[0] * eigv[0] + eigv[1] * eigv[1])) * 180 / M_PI &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;
 
     }
 
     ellipse.close();
 
 
     QString plot_waves, plot_pca, plot_ellipses, plot_hist, plot_process;
 
     FILE *gp = popen(<span class="stringliteral">&quot;/usr/local/lib/FEM/gnuplot/bin/gnuplot&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);<span class="comment">//open a pipe to gnuplot</span>
 
     <span class="keywordflow">if</span>(iter == 0){
         plot_waves += <span class="stringliteral">&quot;!rm plot/ *\n&quot;</span>;
     }
 
     plot_waves += <span class="stringliteral">&quot;set terminal postscript landscape enhanced color solid linewidth 1.0 &#39;Helvetica&#39; 15\n&quot;</span>
             <span class="stringliteral">&quot;set output &#39;plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.ps&#39;\n&quot;</span>
             <span class="stringliteral">&quot;set multiplot\n&quot;</span>
             <span class="stringliteral">&quot;set xrange [0:128]\n&quot;</span>
             <span class="stringliteral">&quot;set yrange [-1.5:1.5]\n&quot;</span>
             <span class="stringliteral">&quot;set size 1,0.3\n&quot;</span>
             <span class="stringliteral">&quot;set origin 0,0.8\n&quot;</span>
             <span class="stringliteral">&quot;set key off\n&quot;</span>;
 
     plot_pca += <span class="stringliteral">&quot;reset\n&quot;</span>
             <span class="stringliteral">&quot;set key off\n&quot;</span>
             <span class="stringliteral">&quot;set size 1,0.7\n&quot;</span>
             <span class="stringliteral">&quot;set origin 0,0.15\n&quot;</span>
             <span class="stringliteral">&quot;set style data points\n&quot;</span>
             <span class="stringliteral">&quot;set yrange []\n&quot;</span>
             <span class="stringliteral">&quot;set xrange []\n&quot;</span>;
 
     plot_hist = <span class="stringliteral">&quot;set origin 0,-0.1\n&quot;</span>
             <span class="stringliteral">&quot;set size 1,0.3\n&quot;</span>
             <span class="stringliteral">&quot;set boxwidth 0.8\n&quot;</span>
             <span class="stringliteral">&quot;set style fill solid\n&quot;</span>
             <span class="stringliteral">&quot;set yrange [0:0.3]\n&quot;</span>
             <span class="stringliteral">&quot;set xrange [-0.5:0.5]\n&quot;</span>;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt;= n_data_points; i+=1){
 
         <span class="keywordtype">int</span> max = 0;
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 1; j &lt; z_ij.n_cols(); j++)
             <span class="keywordflow">if</span>(z_ij(i-1, j) &gt; z_ij(i-1, max))
                 max = j;
 
         <span class="keywordtype">int</span> outlier = 1;
         <span class="keywordflow">if</span>(u_ij(i-1, max) &lt; 0.75) outlier = 4;
         <span class="keywordflow">if</span>(u_ij(i-1, max) &lt; 0.4) outlier = 6;
 
         outlier = 1;
 
         <span class="keywordflow">if</span>(i == 1){
             plot_waves += <span class="stringliteral">&quot;plot&quot;</span>;
             plot_pca += <span class="stringliteral">&quot;plot&quot;</span>;
         }
         <span class="keywordflow">else</span>{
             plot_waves += <span class="stringliteral">&quot;,&quot;</span>;
             plot_pca += <span class="stringliteral">&quot;,&quot;</span>;
         }
 
         plot_waves += <span class="stringliteral">&quot; &#39;output/gnuplot_inputwaves.txt&#39; u &quot;</span> + QString::number(i) +
                 <span class="stringliteral">&quot;with lines lt 1 lc &quot;</span> + QString::number(max);
 
         plot_pca += <span class="stringliteral">&quot; &#39;output/pca_out.txt&#39; every ::&quot;</span> + QString::number(i - 1) + <span class="stringliteral">&quot;::&quot;</span> + QString::number(i - 1) +
                 <span class="stringliteral">&quot; lt &quot;</span> + QString::number(outlier) + <span class="stringliteral">&quot; lc &quot;</span> + QString::number(max);
 
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++){
 
         plot_ellipses += <span class="stringliteral">&quot;, &#39;output/ellipses.dat&#39; every ::&quot;</span> + QString::number(i) + <span class="stringliteral">&quot;::&quot;</span> + QString::number(i) +
                 <span class="stringliteral">&quot; lc &quot;</span> + QString::number(i) + <span class="stringliteral">&quot; with ellipses&quot;</span>;
 
         <span class="keywordflow">if</span>(i == 0)
             plot_hist += <span class="stringliteral">&quot;plot&quot;</span>;
         <span class="keywordflow">else</span>
             plot_hist += <span class="stringliteral">&quot;,&quot;</span>;
 
         plot_hist += <span class="stringliteral">&quot; &#39;output/pi.dat&#39; every ::&quot;</span> + QString::number(i) + <span class="stringliteral">&quot;::&quot;</span> + QString::number(i) +
                 <span class="stringliteral">&quot; lc &quot;</span> + QString::number(i) + <span class="stringliteral">&quot; with histograms&quot;</span>;
 
     }
 
     plot_waves += <span class="stringliteral">&quot;\n&quot;</span>;
     fprintf(gp, plot_waves.toStdString().c_str());
     fflush(gp);
 
     fprintf(gp, plot_pca.toStdString().c_str());
     fflush(gp);
 
     fprintf(gp, <span class="stringliteral">&quot;, &#39;output/em.dat&#39; lt 3&quot;</span>);
 
     plot_ellipses += <span class="stringliteral">&quot;\n&quot;</span>;
     fprintf(gp, plot_ellipses.toStdString().c_str());
     fflush(gp);
 
     plot_hist += <span class="stringliteral">&quot;\n&quot;</span>;
     fprintf(gp, plot_hist.toStdString().c_str());
     fflush(gp);
 
     plot_process = <span class="stringliteral">&quot;!ps2pdf plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.ps plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.pdf\n&quot;</span>
             <span class="stringliteral">&quot;!rm plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.ps\n&quot;</span>
             <span class="stringliteral">&quot;!convert -density 300 plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.pdf plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.jpeg\n&quot;</span>;
 
     <span class="keywordtype">int</span> frames_per_image = 30; <span class="comment">// for video only (set it to 1 if the video is not needed)</span>
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 1; l &lt; frames_per_image; l++)
         plot_process += <span class="stringliteral">&quot;!cp plot/out&quot;</span> + QString::number(iter) + <span class="stringliteral">&quot;.jpeg plot/out&quot;</span> + QString::number(iter + l) + <span class="stringliteral">&quot;.jpeg\n&quot;</span>;
 
     fprintf(gp, plot_process.toStdString().c_str());
     fflush(gp);
 
     fprintf(gp, <span class="stringliteral">&quot;unset multiplot\n&quot;</span>);
 
     pclose(gp);
 
     iter += frames_per_image;
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionrun_Shoham"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::run_Shoham(){
 
     std::fstream file_like;
     file_like.open(<span class="stringliteral">&quot;output/likelihood.dat&quot;</span>, std::ios::out);
 
     initialize_Shoham();
 
     dump();
 
     <span class="keywordtype">int</span> iter = 0;
     T v_old;
     T L_old;
 
     <span class="keywordflow">while</span>(g &gt;= g_min){
 
         <span class="keywordflow">do</span>{
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> o = 0; o &lt; g; o++)
                 std::cout &lt;&lt; pi[o];
 
             v_old = v;
             L_old = L;
 
             e_step_Shoham();
 
             m_step_Shoham();
 
             assemble_P_ij(gamma, v, p, n_data_points, g,
                           Delta.array().val(),
                           delta_ij.array().val(),
                           P_ij.array().val());
 
             pi_d  = pi;
 
             Vector c_d;
 
             c_d = P_ij * pi_d;
 
             <span class="keywordtype">double</span> log_1 = 0.;
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt; g; j++)
                 log_1 += std::log(n_data_points*pi[j]/12);
 
             <span class="keywordtype">double</span> loglike_3 = (N/2)*log_1+(g/2)+(g*(N+1)/2);
 
             T sum;
             sum = sum_array(n_data_points, c_d.array().val(), <span class="keyword">true</span>);
 
             L = sum - loglike_3;
 
             printf(<span class="stringliteral">&quot;###################loglike = %f ########################\n&quot;</span>, L);
 
         } <span class="keywordflow">while</span>(std::fabs(L_old - L) &gt;= 0.1 || std::fabs(v - v_old) &gt;= 0.01);
 
         dump();
 
         file_like &lt;&lt; L &lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt;L_max &lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;v&lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::fabs(L_old - L) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>&lt;&lt;std::fabs(v - v_old)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;g&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
         flush(file_like);
 
         <span class="keywordflow">if</span>(L &gt;= L_max + L_max * 0.09 &amp;&amp; g &gt; g_min){
 
             L_max = L;
 
             pi_opt.resize(pi.size());
             std::copy(pi.begin(), pi.end(), pi_opt.begin());
             mu_opt = mu;
             Sigma_opt.resize(Sigma.size());
             std::copy(Sigma.begin(), Sigma.end(), Sigma_opt.begin());
             v_opt = v;
             u_ij_opt = u_ij;
             z_ij_opt = z_ij;
             P_ij_opt = P_ij;
 
             <span class="keywordtype">int</span> min = 0;
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; pi.size(); i++)
                 <span class="keywordflow">if</span>(pi[i] &lt; pi[min])
                     min = i;
 
             pi[min] = 0;
 
             purge_step_Shoham();
 
         }
         <span class="keywordflow">else</span>
             <span class="keywordflow">break</span>;
 
         iter++;
 
     }
 
     g++;
     pi = pi_opt;
     mu = mu_opt;
     Sigma = Sigma_opt;
     v = v_opt;
     u_ij = u_ij_opt;
     z_ij = z_ij_opt;
     P_ij = P_ij_opt;
 
     dump();
 
     file_like.close();
 
 }
</pre></div><p> <a class="anchor" id="plain-Functioninitialize_Shoham"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::initialize_Shoham()
 {
     it = 0;
     dealii::IdentityMatrix I(p);
 
     mu = mean; <span class="comment">// cluster centers previous calculated by k-means</span>
 
 
     g_min = 1;
 
     pi.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         pi[i] = 1./g;
 
     Sigma.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         Sigma[i] = I;
 
     v = 50;
 
     L_max = -1. * std::numeric_limits&lt;T&gt;::max(); <span class="comment">// -infinity</span>
 
     N = 0.1;<span class="comment">//p;</span>
 
     u_ij.reinit(n_data_points, g);
     z_ij.reinit(n_data_points, g);
     P_ij.reinit(n_data_points, g);
 
     delta_ij.reinit(n_data_points, g);
     Delta.reinit(g);
 
     Sigma_inv.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         Sigma_inv[i] = I;
 
     Sigma_dec.resize(g);
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         Sigma_dec[i] = I;
 
     M.reinit(n_data_points, p);
 
     iter = 0;
 
 
 }
</pre></div><p> <a class="anchor" id="plain-Functione_step_Shoham"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::e_step_Shoham()
 {
 
     Matrix tmp(p, n_data_points);
     Vector c_d;
     std::vector&lt;T&gt; Delta_h(g);
 
     gamma = tgamma((v+p)/2) / (tgamma(v/2)*(std::pow((M_PI*v),(p/2.))));
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;g;j++)
         Delta_h[j] = 1.;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; g; k++){
 
         subtract_array_from_matrix(n_data_points, p, k, g,
                                    data.array().val(),
                                    mu.array().val(),
                                    M.array().val());
 
         tmp = Sigma_inv[k] * tr(M);
 
         MM_scalar(n_data_points, p,
                   M.array().val(),
                   tmp.array().val(),
                   delta_ij.array().val() + k * n_data_points);
     }
 
 
     FullMatrixAccessor delta_ij_h(n_data_points, g, <span class="keyword">true</span>);
     delta_ij_h = delta_ij;
     dealii::Vector&lt;T&gt; delta_ij_array(n_data_points * g);
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt;n_data_points; i++){ <span class="comment">// transpose</span>
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g; j++){
             delta_ij_array(j*n_data_points+i) = delta_ij(i,j);
         }
     }
 
     <span class="keyword">typename</span> dealii::Vector&lt;T&gt;::const_iterator max_delta = std::max_element(delta_ij_array.begin(), delta_ij_array.end());
     <span class="keyword">typename</span> dealii::Vector&lt;T&gt;::const_iterator min_delta = std::min_element(delta_ij_array.begin(), delta_ij_array.end());
 
     T interval = *max_delta - *min_delta;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;n_data_points*g; i++){
         delta_ij_array(i) -= *min_delta;
     }
     delta_ij_array /= interval;
 
 
     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_intervals = 50;
     dealii::Histogram Histogram;
     Histogram.evaluate(delta_ij_array, n_intervals, Histogram.linear);
 
     std::string delta_gram = <span class="stringliteral">&quot;output/delta_gram.dat&quot;</span>;
     std::ofstream dg(delta_gram.c_str());
     Histogram.write_gnuplot(dg);
 
     Delta = Delta_h;
 
     printf(<span class="stringliteral">&quot;gamma = %f\n&quot;</span>, gamma);
 
     assemble_P_ij(gamma, v, p, n_data_points, g,
                   Delta.array().val(),
                   delta_ij.array().val(),
                   P_ij.array().val());
 
     pi_d  = pi;
 
     c_d = P_ij * pi_d;
 
     <span class="keywordflow">if</span>(it++==0)
         assemble_z_ij(n_data_points, g,
                       P_ij.array().val(),
                       c_d.array().val(),
                       pi_d.array().val(),
                       z_ij.array().val());
 
 
 
 
     assemble_u_ij(v, p, n_data_points, g,
                   delta_ij.array().val(),
                   u_ij.array().val());
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionm_step_Shoham"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::m_step_Shoham()
 {
 
     <span class="keywordtype">double</span> digamma;
     Matrix P_ij_tmp = P_ij;
     Matrix z_ij_tmp = z_ij;
     Matrix q_ij(n_data_points, g);
     dealii::IdentityMatrix I(p);
 
     digamma = boost::math::digamma((p+v)/2.);
 
     <span class="keywordtype">double</span> y = calculate_y(n_data_points,
                            g,
                            v,
                            digamma,
                            z_ij.array().val(),
                            delta_ij.array().val(),
                            u_ij.array().val());
 
     y /= -n_data_points;
 
     y = std::max(y, 2.);
     printf(<span class="stringliteral">&quot;y = %f \n&quot;</span>, y);
 
     z_ij_tmp = z_ij;
     T max, sum_pi = 2., tmp_sum[g];
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         tmp_sum[j] = 0.;
     }
 
     <span class="keywordtype">int</span> rel[g];
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++) rel[i] = 0;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n_data_points; i++){
 
         <span class="keywordtype">int</span> max = 0;
 
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 1; j &lt; g; j++)
             <span class="keywordflow">if</span>(z_ij(i, j) &gt; z_ij(i, max))
                 max = j;
 
         rel[max]++;
 
     }
 
     <span class="keywordtype">int</span> s = 0;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         s+=rel[i];
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         pi[i] = ((<span class="keywordtype">double</span>) rel[i]+1) / (double) s;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         std::cout &lt;&lt; pi[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
 
     purge_step_Shoham();
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         std::cout &lt;&lt; pi[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
 
     fflush(stdout);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; g; i++)
         <span class="keywordflow">if</span>(pi[i] &lt; 0.001) exit(0);
 
     T zxu[g];
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;g; i++){
         zxu[i] = 0.;
     }
 
     sum_array2D(n_data_points, g,
                 z_ij.array().val(),
                 u_ij.array().val(),
                 zxu);
 
     MxM(n_data_points, g,
         z_ij.array().val(),
         u_ij.array().val(),
         q_ij.array().val());
 
     mu = tr(q_ij) * data;
 
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;g; i++){
         MatrixSubRow mu_sub(mu,i,0);
         mu_sub *= 1./zxu[i];
     }
 
 
     M.reinit(n_data_points, p);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j&lt;g; j++){
         SMX(n_data_points,
             p,
             q_ij.array().val(),
             zxu[j],
             j,
             data.array().val(),
             mu.array().val(),
             M.array().val()
             );
 
         Sigma[j] = tr(M)*M;
     }
 
 
     <span class="keywordtype">int</span> Matrix_Size = ((p+step1::DEFAULT_TILE_SIZE-1)/step1::DEFAULT_TILE_SIZE)*step1::DEFAULT_TILE_SIZE;
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k &lt; g; k++){
 
 
         Matrix cholMatrix;
         dealii::IdentityMatrix eye(Matrix_Size);
         cholMatrix = eye;
 
         SubMatrix Sub_cholMatrix(cholMatrix, 0, p, 0 , p);
 
         Sub_cholMatrix = Sigma[k];
 
         step1::Kernels&lt;T&gt; fac_backend;
 
         fac_backend.cholesky.blackbox(cholMatrix.array().val(), cholMatrix.n_cols(), cholMatrix.leading_dim);
 
         SubMatrix Sub_Sigma(Sigma_dec[k], 0,0);
 
         Sub_Sigma = cholMatrix;
 
         T det = 0.;
 
         det = Det(p, Matrix_Size, Sub_cholMatrix.array().val());
         Delta.add(k, det);
 
         Matrix Identity = I;
         Matrix X(p,p);
 
         Sigma_inv[k] = Sigma_dec[k];
         <span class="keyword">const</span> SubMatrix l_d(Sigma_dec[k],0,0);
         <span class="keyword">const</span> SubMatrix rhs(Identity, 0,0);
         SubMatrix x_d(X,0,0);
         SubMatrix inv(Sigma_inv[k],0,0);
 
         RightMSolveTr&lt;T, blas&gt; L_X(trSub(l_d),x_d);
         L_X = rhs;
 
         RightMSolve&lt;T, blas&gt; L_B(l_d, inv);
         L_B = x_d;
 
     }
 
     <span class="keywordtype">double</span> errfunc = boost::math::erf(0.6594*log(2.1971/(y+log(y)-1)));
     v = (2/(y+log(y)-1))+0.0416*(1+errfunc);
 
     printf(<span class="stringliteral">&quot;n_dofs_t_distro = %f\n&quot;</span>, v);
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionpurge_step_Shoham"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::ShohamEM&lt;T, blas&gt;::purge_step_Shoham()
 {
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pi.size(); i++){
 
         <span class="keywordflow">if</span>(pi[i] &lt; 0.0001 &amp;&amp; g&gt;g_min){
 
             pi[i] = pi[g-1];
             pi.resize(g-1);
 
             Sigma[i] = Sigma[g-1];
             Sigma.resize(g-1);
 
             MatrixSubCol subPij_target(P_ij, 0, i);
             MatrixSubCol subPij_source(P_ij, 0, g-1);
             subPij_target = subPij_source;
 
             Matrix new_Pij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Pij, 0, j);
                 MatrixSubCol from(P_ij, 0, j);
 
                 to = from;
 
             }
 
             P_ij = new_Pij;
 
             MatrixSubCol subDeltaij_target(P_ij, 0, i);
             MatrixSubCol subDeltaij_source(P_ij, 0, g-1);
             subDeltaij_target = subDeltaij_source;
 
             Matrix new_Deltaij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Deltaij, 0, j);
                 MatrixSubCol from(delta_ij, 0, j);
 
                 to = from;
 
             }
 
             delta_ij = new_Deltaij;
 
             MatrixSubRow subMu_target(mu, i, 0);
             MatrixSubRow subMu_source(mu, g-1, 0);
             subMu_target = subMu_source;
 
             Matrix new_mu(g-1, p);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubRow to(new_mu, j, 0);
                 MatrixSubRow from(mu, j, 0);
 
                 to = from;
 
             }
 
             mu = new_mu;
 
             MatrixSubCol subUij_target(u_ij, 0, i);
             MatrixSubCol subUij_source(u_ij, 0, g-1);
             subUij_target = subUij_source;
 
             Matrix new_Uij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Uij, 0, j);
                 MatrixSubCol from(u_ij, 0, j);
 
                 to = from;
 
             }
 
             u_ij = new_Uij;
 
             MatrixSubCol subZij_target(z_ij, 0, i);
             MatrixSubCol subZij_source(z_ij, 0, g-1);
             subZij_target = subZij_source;
 
             Matrix new_Zij(n_data_points, g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++){
 
                 MatrixSubCol to(new_Zij, 0, j);
                 MatrixSubCol from(z_ij, 0, j);
 
                 to = from;
 
             }
 
             z_ij = new_Zij;
 
             Delta.set(i, Delta(g-1));
             Vector newDelta;
             newDelta.reinit(g-1);
 
             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; g-1; j++)
                 newDelta.set(j, Delta(j));
 
             Delta = newDelta;
 
             Sigma_inv[i] = Sigma_inv[g-1];
             Sigma_inv.resize(g-1);
 
             Sigma_dec[i] = Sigma_dec[g-1];
             Sigma_dec.resize(g-1);
 
             g--;
 
             <span class="keywordflow">if</span>(pi[i] == 0) <span class="comment">// copied one is zero</span>
                 i--;
 
             purge_step_Shoham();
 
             <span class="keywordflow">break</span>;
 
         }
 
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-DestructorShohamEM"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::ShohamEM&lt;T, blas&gt;::~ShohamEM()
 {
     BW::Shutdown();
 }
</pre></div><p> <a class="anchor" id="plain-ConstructorKernelTest"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::KernelTest&lt;T, blas&gt;::KernelTest(<span class="keywordtype">int</span> n_data_points, <span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> n_clusters)
     :
       n_data_points(n_data_points), dim(dim),
       n_clusters(n_clusters)
 {
     BW::Init();
 }
</pre></div><p> <a class="anchor" id="plain-Functionrun"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::KernelTest&lt;T, blas&gt;::run()
 {
     <span class="keywordtype">int</span> Matrix_Size = ((dim+step1::DEFAULT_TILE_SIZE-1)/step1::DEFAULT_TILE_SIZE)*step1::DEFAULT_TILE_SIZE;
 
     FullMatrixAccessor Test_Matrix(n_data_points, dim, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix2(n_clusters, dim, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix3(n_data_points, dim, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix4(dim, n_data_points, <span class="keyword">true</span>);
 
     FullMatrixAccessor Test_Matrix_ij(n_data_points, n_clusters, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix_ij2(n_data_points, n_clusters, <span class="keyword">true</span>);
     FullMatrixAccessor Test_Matrix_ij3(n_data_points, n_clusters, <span class="keyword">true</span>);
 
     std::vector&lt;T&gt; Delta_h(n_clusters);
     std::vector&lt;T&gt; c_h(n_data_points);
     std::vector&lt;T&gt; pi_h(n_clusters);
     Vector Delta, c, pi;
 
     T zxu[n_clusters];
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;n_clusters; i++){
         zxu[i] = 0.;
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; n_data_points; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;dim; j++){
             Test_Matrix(i,j) = (i+1)/10.;
             Test_Matrix3(i,j) = 0.;
             Delta_h[j] = 1.;
             c_h[i] = 1.;
             pi_h[j] = 1/n_clusters;
         }
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; n_clusters; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;dim; j++){
             Test_Matrix2(i,j) = (i+1)/10.;
         }
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; dim; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n_data_points; j++){
             Test_Matrix4(i,j) = (i+1)/10.;
         }
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; n_data_points; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;n_clusters; j++){
             Test_Matrix_ij(i,j) = (i+1)/10.;
             Test_Matrix_ij2(i,j) = (i+1)/10.;
             Test_Matrix_ij3(i,j) = (i+1)/10.;
         }
     }
 
     Matrix Test, Test2, Test3, Test4, Test_ij, Test_ij2, Test_ij3;
     Test = Test_Matrix;
     Test2 = Test_Matrix2;
     Test3 = Test_Matrix3;
     Test4 = Test_Matrix4;
     Test_ij = Test_Matrix_ij;
     Test_ij2 = Test_Matrix_ij2;
     Test_ij3 = Test_Matrix_ij3;
     Delta = Delta_h;
     c = c_h;
     pi = pi_h;
 
     subtract_array_from_matrix(n_data_points, dim, 1, n_clusters,
                                Test.array().val(),
                                Test2.array().val(),
                                Test3.array().val());
 
     printf(<span class="stringliteral">&quot;dim = %d\n&quot;</span>, dim);
 
 
     MM_scalar(n_data_points, dim,
               Test3.array().val(),
               Test4.array().val(),
               Test.array().val());
 
     Det(dim, Matrix_Size, Test3.array().val());
 
     assemble_P_ij(0.5, 50, dim, n_data_points, n_clusters,
                   Delta.array().val(),
                   Test_ij.array().val(),
                   Test_ij2.array().val());
 
     assemble_u_ij(50, dim, n_data_points, n_clusters,
                   Test_ij.array().val(),
                   Test_ij2.array().val());
 
     assemble_z_ij(n_data_points, n_clusters,
                   Test_ij.array().val(),
                   c.array().val(),
                   pi.array().val(),
                   Test_ij2.array().val());
 
     calculate_y(n_data_points, n_clusters, 0.5, 13,
                 Test_ij.array().val(),
                 Test_ij2.array().val(),
                 Test_ij3.array().val());
 
     sum_array(n_data_points, c.array().val(), <span class="keyword">false</span>);
 
     sum_array2D(n_data_points, n_clusters,
                 Test_ij.array().val(),
                 Test_ij2.array().val(),
                 zxu);
 
     MxM(n_data_points, n_clusters,
         Test_ij.array().val(),
         Test_ij2.array().val(),
         Test_ij3.array().val());
 
     SMX(n_data_points, dim,
         Test_ij.array().val(),
         zxu[2],
         2,
         Test.array().val(),
         Test2.array().val(),
         Test3.array().val());
 }
</pre></div><p> <a class="anchor" id="plain-DestructorKernelTest"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::KernelTest&lt;T, blas&gt;::~KernelTest()
 {
     BW::Shutdown();
 }
<span class="preprocessor"> #endif // CUDA_DRIVER_STEP_7_HH</span>
<span class="preprocessor"></span> 
 
 
 / *This file is part of SciPAL.
 
     SciPAL is free software: you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     SciPAL is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License <span class="keywordflow">for</span> more details.
 
     You should have received a copy of the GNU Lesser General Public License
     along with SciPAL.  If not, see &lt;http:<span class="comment">//www.gnu.org/licenses/&gt;.</span>
 
 Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * /
 
 
<span class="preprocessor"> #include &lt;iostream&gt;</span>
<span class="preprocessor"> #include &lt;vector&gt;</span>
<span class="preprocessor"> #include &lt;fstream&gt;</span>
 
<span class="preprocessor"> #include &lt;QString&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_driver_step-7.h&gt;</span>
 
<span class="preprocessor"> #include &lt;deal.II/lac/matrix_out.h&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_driver_step-7.hh&gt;</span>
 
<span class="preprocessor"> #include &lt;waveforms_generator.h&gt;</span>
 
<span class="preprocessor"> #include &lt;step-4.hh&gt;</span>
 
<span class="preprocessor"> #include &lt;cuda_driver_step-5.h&gt;</span>
<span class="preprocessor"> #include &lt;cuda_driver_step-5.hh&gt;</span>
 
 <span class="keyword">namespace </span>step7 {
</pre></div><p> <a class="anchor" id="plain-ClassSimParams"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keyword">struct </span>SimParams : <span class="keyword">public</span> step4::QRTestUIParams
<span class="preprocessor">         #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>         , step6::SimParam
<span class="preprocessor">         #endif</span>
<span class="preprocessor"></span> 
 {
 
     <span class="keyword">typedef</span> step4::QRTestUIParams Base1;
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> step6::SimParam Base2;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     SimParams() : Base1()
   #ifdef USE_KMEANS
       , Base2()
   #endif
     {}
 
     <span class="keyword">static</span> <span class="keywordtype">void</span> declare(dealii::ParameterHandler &amp; prm);
 
     <span class="keywordtype">void</span> <span class="keyword">get</span>(dealii::ParameterHandler &amp; prm);
 
     dealii::FullMatrix&lt;T&gt; waveforms;
     dealii::FullMatrix&lt;T&gt; check_waves;
 
     <span class="keywordtype">int</span> n_forms, n_rows, n_cols;
     <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">int</span> forms = 3;
     T noise;
     std::vector&lt;double&gt; waves_parameters;
     std::vector&lt;int&gt; n_waves;
     QString number_of_waves;
     std::string output_folder;
 
     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_components, max_iter;
 
     <span class="keywordtype">double</span> ev_tol;
 
 <span class="keyword">public</span>:
 
     <span class="keywordtype">void</span> generate_waveforms();
 
 };
</pre></div><p> <a class="anchor" id="plain-ClassPCA"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt; <span class="keyword">class </span>PCA {
 
 <span class="keyword">public</span>:
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix       Matrix;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;              tr;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix    SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector       Vector;
 
 
     PCA(dealii::ParameterHandler &amp; prm);
     <span class="keywordtype">void</span> run();
 
 
     Matrix Q_x_scores;
     Matrix d_scores;
     Matrix d_loadings;
 
 <span class="keyword">private</span>:
     <span class="keywordtype">void</span> factorize(dealii::FullMatrix&lt;T&gt; &amp;A);
 
     <span class="keywordtype">void</span> check_results(<span class="keyword">const</span> dealii::FullMatrix&lt;T&gt; &amp; A,
                        <span class="keyword">const</span> step4::CudaQRDecomposition&lt;T, blas&gt;&amp; QRf,
                        T elapsed_time);
 
     <span class="keywordtype">void</span> save_results();
 
     dealii::FullMatrix&lt;T&gt; Q, B, P_t, H;
 
     SimParams&lt;T&gt; params;
 
     dealii::ConvergenceTable results_table;
 
     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_successful_measurements;
 };
</pre></div><p> <a class="anchor" id="plain-ClassMyFancySimulation"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keyword">class </span>MyFancySimulation {
 
 <span class="keyword">public</span>:
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::FullMatrixAccessor FullMatrixAccessor;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Matrix       Matrix;
     <span class="keyword">typedef</span>          transpose&lt;Matrix&gt;              tr;
 
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::SubMatrix    SubMatrix;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::MatrixSubCol MatrixSubCol;
     <span class="keyword">typedef</span> <span class="keyword">typename</span> blas_pp&lt;T, blas&gt;::Vector       Vector;
 
     MyFancySimulation(std::string prm_filename);
 
     <span class="keywordtype">void</span> run();
 
     <span class="keywordtype">void</span> run_pca(dealii::ParameterHandler &amp;prm_handler);
 
     <span class="keywordtype">void</span> run_cluster_analysis();
 
 <span class="keyword">private</span>:
 
     SimParams&lt;T&gt; params;
 
     FullMatrixAccessor data;
     FullMatrixAccessor loadings;
     FullMatrixAccessor  scores;
 };
</pre></div><p> <a class="anchor" id="plain-ConstructorPCA"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 step7::PCA&lt;T, blas&gt;::PCA(dealii::ParameterHandler &amp;prm)
     :
       n_successful_measurements(0)
 {
     params.get(prm);
 }
</pre></div><p> <a class="anchor" id="plain-Functionrun"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span> step7::PCA&lt;T, blas&gt;::run() {
 
     params.generate_waveforms();
 
     std::string wforms = <span class="stringliteral">&quot;output/wforms.txt&quot;</span>;
     std::ofstream wf(wforms.c_str());
     params.waveforms.print(wf, 12 / *width; avoids that two numbers appear as one in the output* /);
 
     factorize(params.waveforms);
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionfactorize"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> blas&gt;
 <span class="keywordtype">void</span>
 step7::PCA&lt;T, blas&gt;::factorize(dealii::FullMatrix&lt;T&gt; &amp;A)
 {
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- FACTORIZE ----------&quot;</span> &lt;&lt; std::endl;
 
     step4::CudaQRDecomposition&lt;T, blas&gt; QR;
 
     QR.householder(A);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
     FullMatrixAccessor R_tmp;
     R_tmp = QR.R();
 
 
     dealii::FullMatrix&lt;T&gt; R_tmp_h(R_tmp.n_rows(), R_tmp.n_cols());
 
     std::ofstream R_out(<span class="stringliteral">&quot;output/R_mea.dat&quot;</span>);
 
     std::cout&lt;&lt; <span class="stringliteral">&quot;R dimensions = &quot;</span> &lt;&lt; R_tmp.n_rows() &lt;&lt; <span class="stringliteral">&quot; X &quot;</span> &lt;&lt; R_tmp.n_cols() &lt;&lt; std::endl;
     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; R_tmp_h.n_rows(); ++r)
     {
         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; R_tmp_h.n_cols(); ++c)
         {
             R_tmp_h(r, c) = R_tmp(r, c);
             R_out &lt;&lt; R_tmp_h(r, c) &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span>;
         }
         R_out  &lt;&lt; std::endl;
     }
     std::cout  &lt;&lt; std::endl;
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- NIPALS ----------&quot;</span> &lt;&lt; std::endl;
 
     step5::CudaNIPALS&lt;T, blas&gt; nipals(params.n_components,
                                       -1/ *params.max_iter* /,
                                       params.ev_tol);
 
     nipals.get_pca(R_tmp_h);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
     nipals.lambda.print(std::cout);
 
 
     Q_x_scores.reinit(params.n_rows,params.n_components);
 
     SubMatrix sub_Q(const_cast&lt;Matrix &amp;&gt;(QR.Q()),0,params.n_rows,0,params.n_cols);
 
     SubMatrix scores(const_cast&lt;Matrix &amp;&gt;(nipals.scores()),0,0);
 
     SubMatrix Q_x_s(const_cast&lt;Matrix &amp;&gt;(Q_x_scores),0,0);
 
 
     d_scores.reinit(nipals.scores().n_rows(), nipals.scores().n_cols());
     d_scores = nipals.scores();
 
     d_loadings.reinit(nipals.loads().n_rows(),nipals.loads().n_cols());
     d_loadings = nipals.loads();
 
     Matrix Q_tmp, S_tmp, P_tmp;
     Q_tmp = QR.Q();
     S_tmp = nipals.scores();
     P_tmp = Q_tmp * S_tmp;
 
     Q_x_scores = P_tmp;
 
     std::ofstream PCA_out(<span class="stringliteral">&quot;output/pca_out.txt&quot;</span>);
     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = 0; r &lt; P_tmp.n_rows(); r++){
         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; P_tmp.n_cols(); c++)
             PCA_out&lt;&lt;P_tmp(r,c)&lt;&lt;<span class="stringliteral">&quot;\t&quot;</span>;
         PCA_out&lt;&lt;<span class="stringliteral">&quot;\n&quot;</span>;
     }
 
 }
</pre></div><p> <a class="anchor" id="plain-Functiondeclare"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::SimParams&lt;T&gt;::declare(dealii::ParameterHandler &amp;prm)
 {
     Base1::declare(prm);
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     Base2::declare(prm);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     prm.enter_subsection(<span class="stringliteral">&quot;Waveforms parameters&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Number of waves&quot;</span>, <span class="stringliteral">&quot;300,300,300&quot;</span>,
                       dealii::Patterns::Anything(),
                       <span class="stringliteral">&quot;Number of Waves&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Noise intensity&quot;</span>, <span class="stringliteral">&quot;0.2&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Noise intensity&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Number of columns&quot;</span>, <span class="stringliteral">&quot;128&quot;</span>,
                       dealii::Patterns::Integer(),
                       <span class="stringliteral">&quot;Number of columns&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center of Wave 1&quot;</span>, <span class="stringliteral">&quot;0.25&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Center of Wave 1&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Sigma of Wave 1&quot;</span>, <span class="stringliteral">&quot;0.09&quot;</span>,
                       dealii::Patterns::Double(0.01,0.09),
                       <span class="stringliteral">&quot;Sigma of Wave 1 (standard deviation of gaussian)&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center of Wave 2&quot;</span>, <span class="stringliteral">&quot;0.85&quot;</span>,
                       dealii::Patterns::Double(0., 1.),
                       <span class="stringliteral">&quot;Center of Wave 2&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center 1 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.6&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Center 1 of Wave 3&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Center 2 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.65&quot;</span>,
                       dealii::Patterns::Double(0.,0.9),
                       <span class="stringliteral">&quot;Center 2 of Wave 3&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Sigma 1 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.05&quot;</span>,
                       dealii::Patterns::Double(0.01,0.09),
                       <span class="stringliteral">&quot;Sigma 1 of Wave 3 (Lorenz)&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Sigma 2 of Wave 3&quot;</span>, <span class="stringliteral">&quot;0.06&quot;</span>,
                       dealii::Patterns::Double(0.01,0.09),
                       <span class="stringliteral">&quot;Sigma 2 of Wave 3&quot;</span>);
 
     prm.declare_entry (<span class="stringliteral">&quot;Output folder&quot;</span>,
                        <span class="stringliteral">&quot;output&quot;</span>,
                        dealii::Patterns::Anything(),
                        <span class="stringliteral">&quot;output folder location&quot;</span>);
 
     prm.leave_subsection();
 
     prm.enter_subsection(<span class="stringliteral">&quot;NIPALS parameters&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Number of components&quot;</span>, <span class="stringliteral">&quot;2&quot;</span>,
                       dealii::Patterns::Integer(),
                       <span class="stringliteral">&quot;Number of components&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>,
                       dealii::Patterns::Integer(),
                       <span class="stringliteral">&quot;Maximal number of iterations. &quot;</span>
                       <span class="stringliteral">&quot;If -1 is given termination of NIPALS iterations &quot;</span>
                       <span class="stringliteral">&quot;solely depends on the given tolerance&quot;</span>);
 
     prm.declare_entry(<span class="stringliteral">&quot;Tolerance for eigenvalues&quot;</span>,
                       <span class="stringliteral">&quot;1e-5&quot;</span>,
                       dealii::Patterns::Double(),
                       <span class="stringliteral">&quot;Once the relative change of an eigenvalue in the inner &quot;</span>
                       <span class="stringliteral">&quot;power iteration is les than the given value iteration &quot;</span>
                       <span class="stringliteral">&quot;stops and the next principal component is computed.&quot;</span>);
 
     prm.leave_subsection();
 
 }
</pre></div><p> <a class="anchor" id="plain-Functionget"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::SimParams&lt;T&gt;::get(dealii::ParameterHandler &amp;prm)
 {
 
     this-&gt;Base1::get(prm);
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     this-&gt;Base2::get(prm);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     prm.enter_subsection(<span class="stringliteral">&quot;Waveforms parameters&quot;</span>);
 
     number_of_waves = QString(prm.get(<span class="stringliteral">&quot;Number of waves&quot;</span>).c_str());
 
     noise = prm.get_double(<span class="stringliteral">&quot;Noise intensity&quot;</span>);
 
     n_cols = prm.get_integer(<span class="stringliteral">&quot;Number of columns&quot;</span>);
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center of Wave 1&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Sigma of Wave 1&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center of Wave 2&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center 1 of Wave 3&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Center 2 of Wave 3&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Sigma 1 of Wave 3&quot;</span>));
 
     waves_parameters.push_back(prm.get_double(<span class="stringliteral">&quot;Sigma 2 of Wave 3&quot;</span>));
 
     output_folder = prm.get (<span class="stringliteral">&quot;Output folder&quot;</span>);
 
     QDir dir(<span class="stringliteral">&quot;plot&quot;</span>);
 
     <span class="keywordflow">if</span>(!dir.exists()){
         <span class="keywordtype">bool</span> mkdir = dir.mkpath(<span class="stringliteral">&quot;./&quot;</span>);
         AssertThrow(mkdir, dealii::ExcMessage(<span class="stringliteral">&quot;creating a new Folder failed&quot;</span>));
     }
 
     prm.leave_subsection();
 
     prm.enter_subsection(<span class="stringliteral">&quot;NIPALS parameters&quot;</span>);
 
     this-&gt;n_components = prm.get_integer(<span class="stringliteral">&quot;Number of components&quot;</span>);
 
     this-&gt;max_iter = prm.get_integer(<span class="stringliteral">&quot;Maximal number of iterations&quot;</span>);
 
     this-&gt;ev_tol   = prm.get_double(<span class="stringliteral">&quot;Tolerance for eigenvalues&quot;</span>);
 
     prm.leave_subsection();
 
 }
</pre></div><p> <a class="anchor" id="plain-Functiongenerate_waveforms"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::SimParams&lt;T&gt;::generate_waveforms()
 {
     QStringList number_list = number_of_waves.split(<span class="stringliteral">&quot;,&quot;</span>, QString::SkipEmptyParts);
 
     <span class="keywordflow">if</span>(number_list.size()&lt;forms)
     {
         std::cout&lt;&lt;<span class="stringliteral">&quot;more waves numbers needed!&quot;</span>&lt;&lt;std::endl;
         exit(1);
     }
 
     QStringList::iterator e = number_list.begin();
     QStringList::iterator end = number_list.end();
 
     <span class="keywordtype">int</span> i=0, sum = 0;
     n_waves.resize(forms);
     n_forms = 0;
 
     <span class="keywordflow">for</span>(; e!= end; ++e, ++i)
     {
         <span class="keywordflow">if</span>(i==forms) <span class="keywordflow">break</span>;
         n_waves[i] = e-&gt;toInt();
     }
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;forms;i++){
         sum += n_waves[i];
         <span class="keywordflow">if</span>(n_waves[i]!=0) n_forms++;
     }
 
     n_rows = sum;
 
     waveforms.reinit(n_rows,n_cols);
     check_waves.reinit(n_forms,n_cols);
     WaveForms::generate_waveforms(n_rows, n_cols, waveforms, n_waves, noise, waves_parameters);
     WaveForms::normalize_waveforms(n_rows, n_cols, waveforms);
     WaveForms::original_waveforms(n_cols,n_forms,check_waves, waves_parameters, n_waves);
 
     dealii::MatrixOut matrix_out;
     std::string wave_forms = output_folder+<span class="stringliteral">&quot;/waveforms.txt&quot;</span>;
     std::ofstream waf(wave_forms.c_str());
     matrix_out.build_patches(waveforms, <span class="stringliteral">&quot;waveforms&quot;</span>);
     matrix_out.write_gnuplot(waf);
 
     dealii::MatrixOut original_out;
     std::string original_forms = output_folder+<span class="stringliteral">&quot;/originalforms.txt&quot;</span>;
     std::ofstream oaf(original_forms.c_str());
     original_out.build_patches(check_waves, <span class="stringliteral">&quot;originalforms&quot;</span>);
 
 }
 
 }
</pre></div><p> <a class="anchor" id="plain-ConstructorMyFancySimulation"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 step7::MyFancySimulation&lt;T&gt;::MyFancySimulation(std::string prm_filename)
 {
     dealii::ParameterHandler param_handler;
     SimParams&lt;T&gt;::declare(param_handler);
 
     param_handler.read_input(prm_filename);
     params.get(param_handler);
 }
</pre></div><p> <a class="anchor" id="plain-Funktionrun"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::MyFancySimulation&lt;T&gt;::run()
 {
 
 
 }
 
 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::MyFancySimulation&lt;T&gt;::run_pca(dealii::ParameterHandler &amp;prm_handler)
 {
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;Householder-QR mit cublas :\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;
 
     PCA&lt;T, blas&gt; cublas_pca(prm_handler);
 
     cublas_pca.run();
     data = cublas_pca.Q_x_scores;
     loadings = cublas_pca.d_loadings;
     scores = cublas_pca.d_scores;
     std::cout &lt;&lt; <span class="stringliteral">&quot;\nHouseholder-QR mit cublas DONE \n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------\n&quot;</span> &lt;&lt; std::endl;
 
 }
</pre></div><p> <a class="anchor" id="plain-Funktionrun_cluster_analysis"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
 <span class="keywordtype">void</span> step7::MyFancySimulation&lt;T&gt;::run_cluster_analysis()
 {
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- START SIMULATION ----------&quot;</span> &lt;&lt; std::endl;
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- GENERATE WAVEFORMS ----------&quot;</span> &lt;&lt; std::endl;
 
     params.generate_waveforms();
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
     std::cout  &lt;&lt; std::endl;
 
     FullMatrixAccessor X(params.waveforms,<span class="keyword">true</span>);
 
     FullMatrixAccessor Y(params.check_waves, <span class="keyword">true</span>);
 
     dealii::FullMatrix&lt;T&gt; data_matrix2(params.n_rows, params.n_cols);
     dealii::FullMatrix&lt;T&gt; data_matrix2t(params.n_cols, params.n_rows);
     X.push_to(data_matrix2);
 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; params.n_rows; i++){
         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; params.n_cols; j++){
             data_matrix2t(j, i) = data_matrix2(i, j);
         }
     }
 
     std::string sdata2 = <span class="stringliteral">&quot;output/data22.txt&quot;</span>;
     std::ofstream d2(sdata2.c_str());
     data_matrix2.print(d2, 12 / *width; avoids that two numbers appear as one in the output* /);
     std::string sdata2t = <span class="stringliteral">&quot;output/gnuplot_inputwaves.txt&quot;</span>;
     std::ofstream d2t(sdata2t.c_str());
     data_matrix2t.print(d2t, 12 / *width; avoids that two numbers appear as one in the output* /);
 
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span> 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- KMEANS ----------&quot;</span> &lt;&lt; std::endl;
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;n_clusters= &quot;</span> &lt;&lt; params.n_clusters &lt;&lt;std::endl;
 
     step6::Kmeans&lt;double, cublas&gt; cluster_search(data,params.mmeans,params.max_iter);
     cluster_search.initial_computation(params.method);
     cluster_search.iterate(params.method,params.max_iter);
 
     std::string smmeans = <span class="stringliteral">&quot;output/mmeans.txt&quot;</span>;
     std::ofstream j(smmeans.c_str());
     params.mmeans.print(j, 12 / *width; avoids that two numbers appear as one in the output* /);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE ----------&quot;</span> &lt;&lt; std::endl;
 
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     dealii::ParameterHandler prm_debug_handler;
 
     FullMatrixAccessor means(params.mmeans, <span class="keyword">true</span>);
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- SHOHAM ----------&quot;</span> &lt;&lt; std::endl;
 
     step7::ShohamEM&lt;T, cublas&gt; Test(data, means); <span class="comment">// data, means</span>
 
     Test.run_Shoham();
 
     std::cout  &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot; ---------- DONE WITH SHOHAM----------&quot;</span> &lt;&lt; std::endl;
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     std::string smeans = <span class="stringliteral">&quot;output/means.txt&quot;</span>;
     std::ofstream m(smeans.c_str());
     params.mmeans.print(m, 12 / *width; avoids that two numbers appear as one in the output* /);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     std::string oforms = <span class="stringliteral">&quot;output/oforms.txt&quot;</span>;
     std::ofstream of(oforms.c_str());
     params.check_waves.print(of, 12 / *width; avoids that two numbers appear as one in the output* /);
 
<span class="preprocessor"> #ifdef USE_KMEANS</span>
<span class="preprocessor"></span>     dealii::MatrixOut means_out;
     std::string means_forms = params.output_folder+<span class="stringliteral">&quot;/means-waveforms.txt&quot;</span>;
     std::ofstream mf(means_forms.c_str());
     means_out.build_patches(params.mmeans, <span class="stringliteral">&quot;waveforms&quot;</span>);
     means_out.write_gnuplot(mf);
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
 }
</pre></div><p> <a class="anchor" id="plain-Funktionrun_simulation"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> run_simulation(<span class="keywordtype">int</span> / *argc* /, <span class="keywordtype">char</span> *argv[])
 {
     dealii::ParameterHandler prm_handler;
 
<span class="preprocessor"> #ifdef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">float</span> NumberType;
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">double</span> NumberType;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     <span class="keyword">typedef</span> step7::SimParams&lt;NumberType&gt; SimParams;
 
     SimParams::declare(prm_handler);
 
     std::string prm_filename(argv[0]);
     prm_filename += <span class="stringliteral">&quot;.prm&quot;</span>;
     prm_handler.read_input (prm_filename);
 
     prm_filename += <span class="stringliteral">&quot;.log&quot;</span>;
     std::ofstream log_out_text(prm_filename.c_str());
     prm_handler.print_parameters (log_out_text,
                                   dealii::ParameterHandler::Text);
 
     SimParams params;
 
     params.get(prm_handler);
     <span class="keywordtype">int</span> DevNo = 0;
 
     cudaSetDevice(DevNo);           <span class="comment">// select CUDA device</span>
 
     global_data.current_device_id = DevNo;
 
     global_data.cublanc_gpu_info(); <span class="comment">// obtain informations about used GPU</span>
 
<span class="preprocessor"> #ifdef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span>     std::cout &lt;&lt; <span class="stringliteral">&quot;Simulation with float:\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;
 
     step7::MyFancySimulation&lt;float&gt; simu_float(prm_filename);
 
     simu_float.run_pca(prm_handler);
 
     simu_float.run_cluster_analysis();
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;\nSimulation with float DONE \n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>     std::cout &lt;&lt; <span class="stringliteral">&quot;Simulation with double:\n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------&quot;</span> &lt;&lt; std::endl;
 
     fflush(stdout);
 
     step7::MyFancySimulation&lt;double&gt; simu_double(prm_filename);
 
     simu_double.run_pca(prm_handler);
 
     simu_double.run_cluster_analysis();
 
     std::cout &lt;&lt; <span class="stringliteral">&quot;\nSimulation with double DONE \n&quot;</span>
               &lt;&lt; <span class="stringliteral">&quot;------------------------------------------------\n&quot;</span> &lt;&lt; std::endl;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
 }
</pre></div><p> <a class="anchor" id="plain-Funktionrun_kerneltest"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> run_kerneltest(<span class="keywordtype">int</span> / *argc* /, <span class="keywordtype">char</span> *argv[])
 {
 
     <span class="keywordtype">int</span> DevNo = 0;
 
     cudaSetDevice(DevNo);
<span class="preprocessor"> #ifdef USE_SINGLE_PRECISION</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">float</span> NumberType;
<span class="preprocessor"> #else</span>
<span class="preprocessor"></span>     <span class="keyword">typedef</span> <span class="keywordtype">double</span> NumberType;
<span class="preprocessor"> #endif</span>
<span class="preprocessor"></span> 
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_data_points = 100000;
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_sampling_points = 64;
     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> n_clusters = 10;
 
     step7::KernelTest&lt;NumberType, cublas&gt; Test(n_data_points,
                                                n_sampling_points,
                                                n_clusters);
 
     Test.run();
 
 }
 
 <span class="keyword">namespace </span>step7 {
 
 }<span class="comment">// namespace step7 END</span>
</pre></div><p> <a class="anchor" id="plain-Funktionmain"></a> </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
 {
     cudaGetDeviceCount(&amp;global_data.n_CUDA_devices);
     std::cout
             &lt;&lt; <span class="stringliteral">&quot;N available CUDA devices: &quot;</span>
             &lt;&lt; global_data.n_CUDA_devices &lt;&lt; std::endl;
 
     run_simulation(argc, argv);
 
 }
</pre></div> </div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
<img src="logo200.png" alt="blanc++"> documentation generated on Sun Jul 27 2014 17:41:53 by <a href="http://www.doxygen.org/index.html">
doxygen
</a> 1.7.6.1</small></address>
</body>
</html>
