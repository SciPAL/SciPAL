 * <a name="PlainProg"></a>
 * <h1> The plain program</h1>
 * 
 * (If you are looking at a locally installed CUDA HPC Praktikum version, then the
 * program can be found at <i>
 *  .. /.. /testsite / /step-2 /step-cu.cc
 * </i>. Otherwise, this is only
 * the path on some remote server.)
 @code

 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #include <step-2/step-2.hh>
 * 
@endcode
 <a name="plain-Functionmain"></a>
@code
 * int main(int argc, char *argv[])
 * {
 *     step2::MyFancySimulation sim(argc, argv);
 * 
 *     sim.run();
 * }
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef STEP_2_HH
 * #define STEP_2_HH
 * #include <cstdio>
 * #include <vector>
 * 
 * #include <deal.II/base/convergence_table.h>
 * 
 * #include <cuda_runtime.h>
 * #include <../SciPAL/include/base/GPUInfo.h>
 * 
 * #include <QString>
 * 
 * #include <step-2/MVTest.h>
 * #include <step-2/MVTest.hh>
 * 
 * #include <step-2/MVTestUIParams.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-ClassMyFancySimulation"></a>
@code
 * class MyFancySimulation {
 * 
 * public:
 *    MyFancySimulation(int argc, char *argv[]);
 * 
 *    virtual void run();
 * 
 * protected:
 *     virtual void save_results();
 * 
 * 
 *     dealii::ConvergenceTable results_table;
 * 
 *     MVTestUIParams params;
 * 
 *     SciPAL::GPUInfo gpu_info;
 * 
 *     QString launch_dir;
 * 
 *     QString prm_dir;
 * 
 *     QString prm_log_dir;
 * };
 * 
 * }
 * 
@endcode
 <a name="plain-ConstructorMyFancySimulation"></a>
@code
 * step2::MyFancySimulation::MyFancySimulation(int argc, char *argv[])
 * {
 *     cudaGetDeviceCount(&gpu_info.n_CUDA_devices);
 *     std::cout
 *             << "N available CUDA devices : "
 *             << gpu_info.n_CUDA_devices << std::endl;
 * 
 *     gpu_info.get();
 * 
 *     dealii::ParameterHandler prm_handler;
 * 
 *     MVTestUIParams::declare(prm_handler);
 * 
 *      QDir cwd = QDir::current();
 *      cwd.makeAbsolute();
 * 
 *    this->launch_dir = cwd.absolutePath();
 * 
 *     std::string prm_filename;
 * 
 *     if (argc == 1)
 *     {
 *         QFileInfo tmp(argv[0]);
 *         this->prm_dir = tmp.absolutePath() + "/prm";
 *         prm_filename  = tmp.fileName().toStdString();
 *         prm_filename += ".prm";
 *     }
 *     else
 *     {
 *         std::cout << "Given parameter file : " << argv[1] << std::endl;
 * 
 *         QFileInfo tmp(argv[1]);
 * 
 *         if(!tmp.exists())
 *         {
 *             std::cerr << "The following parameter file does not exist:\n"
 *                       << argv[1] << std::endl;
 * 
 *             qFatal("Cannot proceed without proper path to parameter file");
 *         }
 * 
 *         this->prm_dir = tmp.absolutePath();
 * 
 *         prm_filename = tmp.fileName().toStdString();
 * 
 *         std::cout << "xx Parameter file path : "
 *                   << tmp.absolutePath().toStdString().c_str()
 *                   << std::endl;
 *     }
 * 
 *     std::cout << "Parameter file : " << prm_filename  << std::endl;
 * 
 *     cwd.mkpath(this->prm_dir);
 * 
 *     std::cout << "step-2: prm path : " << this->prm_dir.toStdString().c_str()  << std::endl;
 * 
 *     QDir::setCurrent(this->prm_dir);
 * 
 *     prm_handler.read_input (prm_filename);
 * 
 *     this->params.get(prm_handler);
 * 
 *     QDir::setCurrent(this->launch_dir);
 *     cwd.mkpath(this->params.run_dir);
 *     QDir::setCurrent(this->params.run_dir);
 *     cwd = QDir::current();
 *     this->params.run_dir = cwd.absolutePath();
 * 
 *     std::cout << "Entering run dir : " << this->params.run_dir.toStdString().c_str()  << std::endl;
 * 
 * 
 * 
 *     this->prm_log_dir = this->params.run_dir + "/log";
 *     cwd.mkpath(this->prm_log_dir);
 * 
 * 
 * 
 *     QDir::setCurrent(this->prm_log_dir);
 * 
 *     std::ofstream log_out_text( (prm_filename +".log" ).c_str() );
 *     prm_handler.print_parameters (log_out_text,
 *                                   dealii::ParameterHandler::Text);
 * 
 *     assert(QDir::setCurrent(this->params.run_dir ) );
 * 
 *     for(unsigned int i = 0; i < this->params.matrix_sizes.size(); i++)
 *     {
 *         this->results_table.add_value("rows",  (int) this->params.matrix_sizes[i].first);
 *         this->results_table.add_value("columns", (int) this->params.matrix_sizes[i].second);
 *     }
 * }
 * 
@endcode
 <a name="plain-Functionrun"></a>
@code
 * void step2::MyFancySimulation::run()
 * {
 *     const std::vector<MVCase> & float_tests  = this->params.float_tests;
 *     const std::vector<MVCase> & double_tests = this->params.double_tests;
 * 
 *     const std::map<MVCase, int> & float_vs  = this->params.float_vs;
 *     const std::map<MVCase, int> & double_vs = this->params.double_vs;
 * 
 *     QString gpplots_runtimes;
 * 
 *     QString gpplots_speedup;
 * 
 *     QString gnuplot
 *             =
 *             "set term postscript landscape enhanced color solid "
 *             " linewidth 2.0 \"Helvetica\" 20\n"
 *             "set xlabel \"matrix entries\"\n"
 *             "set ylabel \"execution time\"\n"
 *             "set logscale xy\n"
 *             "set grid\n"
 *             "set output \"runtimes.ps\"\n"
 *             "set key inside left Left box lw 0.5\n";
 * 
 *     gnuplot += "plot ";
 * 
 *     std::vector<MVCase>::const_iterator
 *             t = float_tests.begin(),
 *             end_t = float_tests.end();
 * 
 *     int col = 3;
 * 
 *     for (; t != end_t; ++t)
 *     {
 *         MVTest<float> mv_test(this->params, results_table, *t);
 *         if(col > 3) gpplots_runtimes += ",";
 *         gpplots_runtimes += QString("\"../MVTest_results.out\" using (1*2):")
 *                 + QString::number(col++)
 *                 + QString(" title \"") + mv_test.run() + QString("\" w p");
 *     }
 * 
 *     t = double_tests.begin(), end_t = double_tests.end();
 * 
 *     for (; t != end_t; ++t)
 *     {
 *         MVTest<double> mv_test(this->params, results_table, *t);
 *         if(col > 3) gpplots_runtimes += ",";
 *         gpplots_runtimes += QString("\"../MVTest_results.out\" using (1*2):")
 *                 +
 *                 QString::number(col++)
 *                 +
 *                 QString(" title \"") + mv_test.run() + QString("\" w p");
 *     }
 * 
 *     gnuplot += gpplots_runtimes;
 * 
 *     gnuplot +=
 *             "\nset ylabel \"speedup\"\n"
 *             "set output \"speedup.ps\"\n"
 *             "set key inside left Left\n";
 * 
 *     gnuplot += "unset logscale y\n";
 * 
 *     gnuplot += "plot";
 * 
 *     int offset = 3 + this->params.float_vs.size();
 * 
 *     if(this->params.run_cpublas_vs_cublas_float)
 *         gpplots_speedup += ((gpplots_speedup.isEmpty()) ? QString("") : QString(", "))
 *                 + QString("\"../MVTest_results.out\" using (1*2):(%1 / %2)")
 *                 .arg(float_vs.at(atlas_mv) + 3).arg(float_vs.at(cublas_mv) + 3)
 *                 + QString(" title \"CPU BLAS vs CUBLAS (float)\" w p");
 * 
 *     if(this->params.run_cpublas_vs_cublas_double)
 *         gpplots_speedup += ((gpplots_speedup.isEmpty()) ? QString("") : QString(", "))
 *                 + QString("\"../MVTest_results.out\" using (1*2):(%1 / %2)")
 *                 .arg(double_vs.at(atlas_mv) + offset).arg(double_vs.at(cublas_mv) + offset)
 *                 + QString(" title \"CPU BLAS vs CUBLAS (double)\" w p");
 * 
 *     if(this->params.run_cpublas_vs_Fujimoto_float)
 *         gpplots_speedup += ((gpplots_speedup.isEmpty()) ? QString("") : QString(", "))
 *                 + QString("\"../MVTest_results.out\" using (1*2):(%1 / %2)")
 *                 .arg(float_vs.at(atlas_mv) + 3).arg(float_vs.at(Fujimoto_mv) + 3)
 *                 + QString(" title \"CPU BLAS vs Fujimoto (float)\" w p");
 * 
 *     if(this->params.run_cpublas_vs_Fujimoto_double)
 *         gpplots_speedup += ((gpplots_speedup.isEmpty()) ? QString("") : QString(", "))
 *                 + QString("\"../MVTest_results.out\" using (1*2):(%1 / %2)")
 *                 .arg(double_vs.at(atlas_mv) + offset).arg(double_vs.at(Fujimoto_mv) + offset)
 *                 + QString(" title \"CPU BLAS vs Fujimoto (double)\" w p");
 * 
 *     if(this->params.run_Fujimoto_vs_cublas_float)
 *         gpplots_speedup += ((gpplots_speedup.isEmpty()) ? QString("") : QString(", "))
 *                 + QString("\"../MVTest_results.out\" using (1*2):(%1 / %2)")
 *                 .arg(float_vs.at(Fujimoto_mv) + 3).arg(float_vs.at(cublas_mv) + 3)
 *                 + QString(" title \"Fujimoto vs CUBLAS (float)\" w p");
 * 
 *     if(this->params.run_Fujimoto_vs_cublas_double)
 *         gpplots_speedup += ((gpplots_speedup.isEmpty()) ? QString("") : QString(", "))
 *                 + QString("\"../MVTest_results.out\" using (1*2):(%1 / %2)")
 *                 .arg(double_vs.at(Fujimoto_mv) + offset).arg(double_vs.at(cublas_mv) + offset)
 *                 + QString(" title \"Fujimoto vs CUBLAS (double)\" w p");
 * 
 *     gnuplot += gpplots_speedup;
 * 
 *     gnuplot += "\n!ps2pdf runtimes.ps runtimes.pdf";
 *     gnuplot += "\n!rm runtimes.ps";
 *     gnuplot += "\n!ps2pdf speedup.ps speedup.pdf";
 *     gnuplot += "\n!rm speedup.ps";
 * 
 * 
 *     std::cout << "Results are processed and saved.\n";
 * 
 *     this->save_results();
 * 
 *      QDir cwd = QDir::current();
 *      QString plot_dir = this->params.run_dir + "/plot";
 *              cwd.mkpath("./plot");
 * 
 *      QDir::setCurrent(plot_dir);
 * 
 * 
 *     QFile plotscript("plot.gp");
 * 
 *     bool success = plotscript.open(QIODevice::WriteOnly);
 *     if (!success)
 *         std::cerr << "Opening gnuplot file failed!" << std::endl;
 * 
 *     plotscript.write(gnuplot.toStdString().c_str());
 * 
 *     plotscript.close();
 * 
 *     if (! plotscript.exists() )
 *         std::cerr << "Writing gnuplot file failed!" << std::endl;
 * 
 * 
 *     FILE *gp = popen("gnuplot -persist", "w");
 *     fprintf(gp, "load \"plot.gp\"\n");
 *     fflush(gp);
 *     pclose(gp);
 * 
 * 
 *     QDir::setCurrent(this->params.run_dir);
 * 
 *     std::cout << "Finished." << std::endl;
 * }
 * 
@endcode
 <a name="plain-Functionsave_results"></a>
@code
 * void step2::MyFancySimulation::save_results()
 * {
 *     std::string filename("MVTest_results");
 * 
 *     filename += ".out";
 * 
 *     std::ofstream out(filename.c_str());
 * 
 *     out << "# max n_cols  : " << this->params.max_n_cols << std::endl
 *         << "# min n_cols  : " << this->params.min_n_cols << std::endl
 *         << "# growth rate : " << this->params.n_rows_growth_rate << std::endl
 *         << std::endl;
 * 
 *     results_table.write_text(out);
 * }
 * 
 * #endif
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef SimUIParams_H
 * #define SimUIParams_H
 * 
 * 
 * #include <QString>
 * #include <deal.II/base/parameter_handler.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-EnumMVCase"></a>
@code
 * enum MVCase { Fujimoto_mv, atlas_mv, cublas_mv, none / * for future use : , openmp_mv, ...* / };
 * 
@endcode
 <a name="plain-structSimUIParams"></a>
@code
 * struct SimUIParams {
 * 
 *     SimUIParams() {}
 * 
 *     static void declare(dealii::ParameterHandler & prm);
 * 
 *     void get(dealii::ParameterHandler & prm);
 * 
 *     bool
 *     run_cpublas_vs_cublas_float,
 *     run_cpublas_vs_cublas_double,
 *     run_cpublas_vs_Fujimoto_float,
 *     run_cpublas_vs_Fujimoto_double,
 *     run_Fujimoto_vs_cublas_float,
 *     run_Fujimoto_vs_cublas_double;
 * 
 *     int fj_version;
 * 
 *     QString run_dir;
 * 
 *     std::vector<MVCase> float_tests, double_tests;
 *     std::map<MVCase, int> float_vs, double_vs;
 * 
 * private:
 *     SimUIParams (const SimUIParams & / *other* /) {}
 * 
 *     SimUIParams & operator = (const SimUIParams & / *other* /) { return *this; }
 * };
 * 
 * }
 * #endif // SimUIParams_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef MVTESTUIPARAMS_H
 * #define MVTESTUIPARAMS_H
 * 
 * #include <step-2/SimUIParams.h>
 * #include <step-2/DeviceParams.h>
 * #include <step-2/MVMultDriverInterface.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-ClassTestUIParamsBase"></a>
@code
 * struct TestUIParamsBase {
 * 
 *     TestUIParamsBase() {}
 * 
 *     static void declare(dealii::ParameterHandler & prm);
 * 
 *     void get(dealii::ParameterHandler & prm);
 * 
 *     int  min_n_cols;
 *     int  max_n_cols;
 * 
 *     double n_rows_growth_rate;
 * 
 *     int n_repetitions;
 * 
 * 
 * private:
 *     TestUIParamsBase(const TestUIParamsBase & ) {}
 * 
 *     TestUIParamsBase & operator = (const TestUIParamsBase & / *other* /)
 *     {
 *         return *this;
 *     }
 * };
 * 
 * 
@endcode
 <a name="plain-ClassMVTestUIParams"></a>
@code
 * struct MVTestUIParams
 *         :
 *         public SimUIParams,
 *         public DeviceParams,
 *         public TestUIParamsBase
 * {
 *     MVTestUIParams()
 *         :
 *           SimUIParams(),
 *           DeviceParams(),
 *           TestUIParamsBase()
 *     {}
 * 
 *     static void declare(dealii::ParameterHandler & prm);
 * 
 *     void get(dealii::ParameterHandler & prm);
 * 
 * 
 *     int n_random_trials;
 * 
 *     std::vector<step2::matrixSize> matrix_sizes;
 * 
 * protected:
 *     void create_random_matrix_sizes();
 *     void create_regular_matrix_sizes();
 * 
 * private:
 *     MVTestUIParams (const MVTestUIParams & / *other* /)
 *         :
 *           SimUIParams(),
 *           DeviceParams(),
 *           TestUIParamsBase()
 *     {}
 * 
 *     MVTestUIParams & operator = (const MVTestUIParams & / *other* /)
 *     {
 *         return *this;
 *     }
 * };
 * 
 * }
 * #endif // MVTESTUIPARAMS_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef MVTEST_H
 * #define MVTEST_H
 * 
 * #include <QDir>
 * #include <step-2/Fujimoto_driver_step-2.h>
 * #include <step-2/cuda_driver_step-2.h>
 * #include <step-2/CpuBlas_driver_step-2.h>
 * #include <step-2/MVTestUIParams.h>
 * 
 * #include <deal.II/base/convergence_table.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-ClassMVTest"></a>
@code
 * template <typename T>
 * class MVTest {
 * 
 * public:
 *     typedef ::FullMatrixAccessor<T> FullMatrixAccessor;
 * 
 *     MVTest(const MVTestUIParams & p,
 *            dealii::ConvergenceTable & results_table,
 *            MVCase variant=atlas_mv);
 * 
 *     ~MVTest();
 * 
 *     virtual QString run();
 * 
 * 
 * protected:
 *     typename step2::MVMultDriverInterface<T> * driver_m;
 * 
 *     virtual void setup_and_assemble(unsigned int nr,
 *                                     unsigned int nc);
 * 
 *     const MVTestUIParams * params;
 * 
 *     FullMatrixAccessor A;
 * 
 *     dealii::Vector<T> x_orig, y_orig;
 * 
 *     std::string col_head;
 * 
 *     dealii::ConvergenceTable & results_table;
 * };
 * }
 * #endif // MVTEST_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef MVTEST_HH
 * #define MVTEST_HH
 * 
 * #include <step-2/MVTest.h>
 * #include <step-2/PrecisionName.h>
 * #include <deal.II/base/convergence_table.h>
 * 
@endcode
 <a name="plain-Constructor"></a>
@code
 * template <typename T>
 * step2::MVTest<T>::MVTest(const step2::MVTestUIParams & p,
 *                          dealii::ConvergenceTable &rt,
 *                          MVCase mv_variant)
 *     :
 *       params(&p),
 *       results_table(rt)
 * {
 *     driver_m = NULL;
 * 
 *     switch (mv_variant) {
 * 
 *     case Fujimoto_mv:
 *         driver_m = new FujimotoDriver<T,cublas> (this->params->fj_version);
 *         col_head = "Fujimoto " + QString::number(this->params->fj_version).toStdString();
 *         break;
 *     case cublas_mv:
 *         driver_m = new CUBlasDriver<T,cublas> ();
 *         col_head  = "CUBLAS";
 *         break;
 *     case atlas_mv:
 *         driver_m = new step2::CpuBlasDriver<T,blas> ();
 *         col_head  = "CPU Blas";
 *         break;
 *     default: // do nothing
 *         break;
 *     }
 * 
 *     if (mv_variant != none)
 *     {
 *         assert(driver_m);
 * 
 *         col_head += " " + PrecisionName<T>::name();
 * 
 *         std::cerr << "\nTesting " << col_head.c_str() << " mvmult "
 *                   << std::endl;
 *     }
 * }
 * 
@endcode
 <a name="plain-Destructor"></a>
@code
 * template <typename T>
 * step2::MVTest<T>::~MVTest()
 * {
 *     if (driver_m)
 *         delete driver_m;
 * }
 * 
 * 
@endcode
 <a name="plain-Functionrun"></a>
@code
 * template <typename T>
 * QString
 * step2::MVTest<T>::run()
 * {
 *     for (size_t i=0; i< this->params->matrix_sizes.size(); i++)
 *     {
 *         size_t nr = this->params->matrix_sizes[i].first ;
 *         size_t nc = this->params->matrix_sizes[i].second;
 * 
 * #ifdef DEBUG
 *         std::cout  << "Testing MV for " << nr << "x" << nc << " matrix" << std::endl;
 * #endif
 *         setup_and_assemble(nr, nc);
 * 
 * 
 *         std::vector<T> x(this->x_orig.begin(), this->x_orig.end());
 * 
 *         unsigned int n_elements =  this->y_orig.size();
 *         std::vector<T> y(n_elements, 0.);
 * 
 *         double elapsed_time
 *                 =
 *                 driver_m->mvmult(y, A, x,
 *                                  this->params->n_repetitions) / this->params->n_repetitions;
 * 
 * 
 *         dealii::Vector<T> diff ( n_elements );
 *         for (unsigned int i = 0; i < n_elements; i++)
 *             diff(i) = (y[i] - y_orig(i)) / y_orig(i);
 * 
 *         double linfty_error = diff.linfty_norm();
 * 
 *         if (linfty_error> (sizeof(T)<8 ? 1e-5 : 1e-14))
 *         {
 *             std::cerr << nr << "x" << nc << " matrix : "
 *                       << "|| (y - y_orig)/y_orig||_infty = " << linfty_error
 *                       << " MVTest probably failed!"
 *                       << std::endl;
 * 
 *             if (y.size() < 20) {
 *                 std::cerr << y_orig << std::endl;
 * 
 *                 std::copy(y.begin(), y.end(), diff.begin());
 *                 std::cerr << diff << std::endl;
 *             }
 *         }
 * 
 *         this->results_table.add_value(col_head.c_str(), elapsed_time);
 * 
 *         this->results_table.set_precision(col_head.c_str(), 12);
 *     }
 * 
 *     return col_head.c_str();
 * }
 * 
 * 
@endcode
 <a name="plain-Functionsetup_and_assemble"></a>
@code
 * template <typename T>
 * void
 * step2::MVTest<T>::setup_and_assemble(unsigned int nr, unsigned int nc)
 * {
 *     this->A.reinit(nr, nc);
 *     this->x_orig.reinit(nc);
 *     this->y_orig.reinit(nr);
 * 
 *     y_orig = 0.;
 *     int tmp = 1;
 *     for (unsigned int r = 0; r < nr; ++r)
 *         for (unsigned int c = 0; c < nc; ++c)
 *         {
 *             x_orig(c)  = (c+1);
 *             A(r,c)     = tmp; tmp++;//r+1 + 1./(c+1);
 *             y_orig(r) +=  A(r,c)*x_orig(c);
 *         }
 * }
 * #endif
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef MVMultDriverInterface_H
 * #define MVMultDriverInterface_H
 * 
 * #include <vector>
 * #include <numeric>
 * #include <lac/blas++.h>
 * 
 * namespace step2 {
 * 
 * typedef    std::pair<size_t, size_t> matrixSize;
 * 
@endcode
 <a name="plain-ClassMVMultDriverInterface"></a>
@code
 * template<typename Number>
 * class MVMultDriverInterface {
 * 
 * public:
 * 
 *     typedef ::FullMatrixAccessor<Number> FullMatrixAccessor;
 * 
 *     MVMultDriverInterface()	{}
 * 
 *     virtual ~MVMultDriverInterface () {}
 * 
@endcode
 <a name="plain-Functionmvmult"></a>
@code
 *     virtual double mvmult(std::vector<Number> & y,
 *                           const FullMatrixAccessor & A,
 *                           const std::vector<Number> & x,
 *                           int n_repetitions) = 0;
 * };
 * 
 * } // namespace step2 END
 * #endif // MVMultDriverInterface_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef CPUBLAS_DRIVER_STEP2_H
 * #define CPUBLAS_DRIVER_STEP2_H
 * 
 * #include <vector>
 * #include <lac/blas++.h>
 * #include <step-2/MVMultDriverInterface.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-ClassCpuBlasDriver"></a>
@code
 * template<typename EntryType, typename blasType>
 * class CpuBlasDriver : public MVMultDriverInterface<EntryType>
 * {
 * public:
 * 
 *     typedef
 *     typename MVMultDriverInterface< EntryType>::FullMatrixAccessor
 *     FullMatrixAccessor;
 * 
 *     CpuBlasDriver() {}
 * 
 *     virtual ~CpuBlasDriver () {}
 * 
 *     virtual double mvmult(std::vector<EntryType>& y,
 *                           const FullMatrixAccessor& A,
 *                           const std::vector<EntryType>& x,
 *                           int n_repetitions);
 * };
 * 
 * } // namespace step2 END
 * 
 * #include <step-2/CpuBlas_driver_step-2.hh>
 * #endif // CPUBLAS_DRIVER_STEP2_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef CPUBLAS_DRIVER_STEP_2_HH
 * #define CPUBLAS_DRIVER_STEP_2_HH
 * 
 * #include <base/CUDATimer.h>
 * 
@endcode
 <a name="plain-Functionmvmult"></a>
@code
 * template<typename EntryType,typename blasType>
 * double step2::CpuBlasDriver<EntryType,blasType>::mvmult(std::vector<EntryType>& y,
 *                                                         const FullMatrixAccessor& A,
 *                                                         const std::vector<EntryType>& x,
 *                                                         int n_repetitions)
 * {
 *     int n_rows = A.n_rows();
 *     int n_cols = A.n_cols();
 * 
 *     EntryType * d_y = &y[0];
 * 
 *     EntryType * d_A = const_cast<FullMatrixAccessor &>(A).val();
 * 
 *     EntryType * d_x = &const_cast<std::vector<EntryType> &>(x)[0];
 * 
 *     EntryType alpha = 1;
 *     EntryType beta  = 1;
 * 
 *     int incx = 1; int incy = 1;
 * 
 *     int lda = n_cols;
 * 
 *     int m = n_cols;
 *     int n = n_rows;
 * 
 *     double cumulative_runtime = 0.;
 *     for (int i=0; i<n_repetitions; i++)
 *     {
 *         for (unsigned int k = 0; k < n_rows; k++)
 *             d_y[k] = 0.;
 * 
 *         CUDATimer timer;
 * 
 *         blasType::gemv ('t', m, n, alpha,
 *                         d_A, lda,
 *                         d_x, incx,
 *                         beta,
 *                         d_y, incy);
 * 
 *         timer.stop();
 *         cumulative_runtime += timer.elapsed();
 *     }
 * 
 *     return cumulative_runtime;
 * }
 * #endif // CPUBLAS_DRIVER_STEP_2_HH
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef CUBlasDriver_STEP_2_H
 * #define CUBlasDriver_STEP_2_H
 * 
 * #include <vector>
 * #include <lac/blas++.h>
 * #include <step-2/MVMultDriverInterface.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-ClassCUBlasDriver"></a>
@code
 * template<typename T,typename blasType=cublas>
 * class CUBlasDriver : public MVMultDriverInterface<T>
 * {
 * public:
 *     typedef
 *     typename MVMultDriverInterface<T>::FullMatrixAccessor
 *     FullMatrixAccessor;
 * 
 * 
 *     CUBlasDriver();
 * 
 *     virtual ~CUBlasDriver ();
 * 
 *     virtual double mvmult(std::vector<T>& y,
 *                           const FullMatrixAccessor& A,
 *                           const std::vector<T>& x,
 *                           int	n_repetitions);
 * };
 * 
 * } // namespace step2 END
 * 
 * #include <step-2/cuda_driver_step-2.hh>
 * #endif // CUBlasDriver_STEP_2_H
 * 
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef CUDA_DRIVER_STEP_2_HH
 * #define CUDA_DRIVER_STEP_2_HH
 * 
 * #include <base/CUDATimer.h>
 * 
@endcode
 <a name="plain-ConstructorCUBlasDriver"></a>
@code
 * template<typename T,typename blasType>
 * step2::CUBlasDriver<T,blasType>::CUBlasDriver() : MVMultDriverInterface<T>()
 * {
 *     blasType::Init();
 * }
 * 
 * 
@endcode
 <a name="plain-DestructorCUBlasDriver"></a>
@code
 * template<typename T,typename blasType>
 * step2::CUBlasDriver<T,blasType>::~CUBlasDriver()
 * {
 *     blasType::Shutdown();
 * }
 * 
 * 
@endcode
 <a name="plain-Functionmvmult"></a>
@code
 * template<typename T,typename blasType>
 * double step2::CUBlasDriver<T,blasType>::mvmult(std::vector<T>& y,
 *                                                const FullMatrixAccessor& A,
 *                                                const std::vector<T>& x,
 *                                                int n_repetitions)
 * {   
 *     int n_rows = A.n_rows();
 *     int n_cols = A.n_cols();
 * 
 *     T * dst = &y[0];
 * 
 *     T * A_entries = const_cast<FullMatrixAccessor &>(A).val();
 * 
 *     T * src = &const_cast<std::vector<T> &>(x)[0];
 * 
 *     T alpha=1.;
 *     T beta=1.;
 *     int incx=1;
 *     int incy=1;
 * 
 *     int lda=n_cols;
 *     int m = n_cols;
 *     int n = n_rows;
 * 
 *     T *d_A, *d_x, *d_y;
 * 
 *     cudaMalloc((void **) &d_A, n_rows * n_cols * sizeof(T));
 * 
 *     cudaMalloc((void **) &d_x, n_cols * sizeof(T));
 *     cudaMalloc((void **) &d_y, n_rows * sizeof(T));
 * 
 *     cudaMemcpy(d_x, src, n_cols * sizeof(T), cudaMemcpyHostToDevice);
 * 
 *     cudaMemcpy(d_A, A_entries, n_rows * n_cols * sizeof(T), cudaMemcpyHostToDevice);
 * 
 *     double cumulative_runtime = 0.;
 *     for (int i=0; i<n_repetitions; i++)
 *     {
 *         cudaThreadSynchronize();
 *         CUDATimer timer;
 * 
 *         cudaMemcpy(d_y, dst, n_rows * sizeof(T), cudaMemcpyHostToDevice);
 * 
 *         blasType::gemv ('t', m, n, alpha,
 *                         d_A, lda,
 *                         d_x,  incx,
 *                         beta,
 *                         d_y,  incy);
 * 
 *         cudaThreadSynchronize();
 *         timer.stop();
 *         cumulative_runtime += timer.elapsed();
 *     }
 * 
 *     cudaMemcpy(dst, d_y, n_rows * sizeof(T), cudaMemcpyDeviceToHost);
 * 
 *     cudaFree(d_y);
 *     cudaFree(d_x);
 *     cudaFree(d_A);
 * 
 *     return cumulative_runtime;
 * }
 * #endif // CUDA_DRIVER_STEP_2_HH
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef FUJIMOTO_DRIVER_step2_H
 * #define FUJIMOTO_DRIVER_step2_H
 * 
 * #include <vector>
 * #include <lac/blas++.h>
 * #include <step-2/MVMultDriverInterface.h>
 * #include <step-2/cuda_kernel_wrapper_step-2.cu.h>
 * 
 * namespace step2 {
 * 
@endcode
 <a name="plain-ClassFujimotoDriver"></a>
@code
 * template<typename T,typename blasType=cublas>
 * class FujimotoDriver : public MVMultDriverInterface<T>, private Kernels<T>
 * {
 * public:
 *     typedef
 *     typename MVMultDriverInterface<T>::FullMatrixAccessor FullMatrixAccessor;
 * 
 *     FujimotoDriver(const int v) : fj_version(v) {}
 * 
 *     virtual  ~FujimotoDriver () {}
 * 
 *     virtual double mvmult(std::vector<T>& y,
 *                           const FullMatrixAccessor& A,
 *                           const std::vector<T>& x,
 *                           int n_repetitions);
 * 
 * protected:
 *     const int fj_version;
 * };
 * 
 * } // namespace step2 END
 * 
 * #include <step-2/Fujimoto_driver_step-2.hh>
 * #endif // FUJIMOTO_DRIVER_step2_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef FUJIMOTO_DRIVER_step2_HH
 * #define FUJIMOTO_DRIVER_step2_HH
 * 
 * #include <step-2/cuda_kernel_wrapper_step-2.cu.h>
 * #include <base/CUDATimer.h>
 * 
@endcode
 <a name="plain-Functionmvmult"></a>
@code
 * template<typename Number,typename blasType>
 * double step2::FujimotoDriver<Number,blasType>::mvmult(std::vector<Number> & y,
 *                                                       const FullMatrixAccessor& A,
 *                                                       const std::vector<Number> & x,
 *                                                       int n_repetitions)
 * {
 *     int n_rows = A.n_rows();
 *     int n_cols = A.n_cols();
 * 
 *     Number * dst = &y[0];
 * 
 *     const Number * A_entries = A.val();
 * 
 *     const Number * src = &x[0];
 * 
 * 
 *     double cumulative_elapsed_time = 0;
 * 
 *     this->mv_fujimoto(dst, A_entries, src,
 *                       n_rows, n_cols,
 *                       n_repetitions,
 *                       this->fj_version,
 *                       cumulative_elapsed_time);
 * 
 *     return cumulative_elapsed_time;
 * }
 * 
 * #endif // FUJIMOTO_DRIVER_step2_HH
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * #ifndef CUDA_KERNEL_STEP_2_CU_H
 * #define CUDA_KERNEL_STEP_2_CU_H
 * 
@endcode
 <a name="plain-DeclarationofCUDAInterface"></a>
@code
 * namespace step2 {
 * 
 * 
@endcode
 <a name="plain-ClassKernels"></a>
@code
 * template<typename T>
 * struct Kernels {
 * 
 *     void mv_fujimoto(T *y, const T *A, const T *x,
 *                      const int m, const int n,
 *                      const int n_repetitions, const int fj_version, double& elapsed_time);
 * };
 * }
 * #endif // CUDA_KERNEL_STEP_2_CU_H
 * 
 * 
 * 
 * / *This file is part of SciPAL.
 * 
 *     SciPAL is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 * 
 *     SciPAL is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 * 
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with SciPAL.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Copyright  S. C. Kramer , J. Hagemann  2010 - 2014
 * * /
 * 
 * 
 * 
 * #include <step-2/cuda_kernel_wrapper_step-2.cu.h>
 * 
 * 
 * #ifndef DONT_USE_CUDATIMER
 * #include <base/CUDATimer.h>
 * #endif
 * 
 * #include <stdio.h>
 * 
@endcode
 <a name="plain-Kernels"></a>
@code
 * namespace step2 {
 * 
 * #define bx blockIdx.x
 * #define tx threadIdx.x
 * #define ty threadIdx.y
 * 
 * 
 * texture<float4, 2, cudaReadModeElementType> fTexRefA;
 * 
@endcode
 <a name="plain-Kernel_mv_fujimoto"></a>
@code
 * __global__
 * void
 * _mv_fujimoto(float* y, cudaArray* A, float* x, int m, int n)
 * {
 *     __shared__ float xs[16][16];
 * 
 *     __shared__ float Ps[16][16];
 * 
 *     float4 a;
 * 
 *     float *Psptr = (float *) Ps + (ty << 4) + tx;
 *     int ay = (bx << 4) + ty;
 *     float *xptr = x + (ty << 4) + tx;
 *     float *xsptr = (float *) xs + (tx << 2);
 * 
 *     *Psptr = 0.0f;
 * 
 *     int i;
 *     for (i = 0; i < (n & ~255); i += 256, xptr += 256)
 *     {
 *         xs[ty][tx] = *xptr;
 *         __syncthreads();
 * 
 *         int ax = tx + (i >> 2);
 * 
 *         a = tex2D(fTexRefA, ax     , ay);
 *         *Psptr += a.x * *xsptr         + a.y * *(xsptr +   1) + a.z * *(xsptr +   2) + a.w * *(xsptr +   3);
 * 
 *         a = tex2D(fTexRefA, ax + 16, ay);
 *         *Psptr += a.x * *(xsptr +  64) + a.y * *(xsptr +  65) + a.z * *(xsptr +  66) + a.w * *(xsptr +  67);
 * 
 *         a = tex2D(fTexRefA, ax + 32, ay);
 *         *Psptr += a.x * *(xsptr + 128) + a.y * *(xsptr + 129) + a.z * *(xsptr + 130) + a.w * *(xsptr + 131);
 * 
 *         a = tex2D(fTexRefA, ax + 48, ay);
 *         *Psptr += a.x * *(xsptr + 192) + a.y * *(xsptr + 193) + a.z * *(xsptr + 194) + a.w * *(xsptr + 195);
 * 
 *         __syncthreads();
 *     }
 * 
 *     if (i + (ty << 4) + tx < n) {
 *         xs[ty][tx] = *xptr;
 *     }
 *     __syncthreads();
 * 
 *     int j;
 *     for (j = 0; j < ((n - i) >> 6); j++, xsptr += 61) {
 *         a = tex2D(fTexRefA, tx + (i >> 2) + (j << 4), ay);
 *         *Psptr += a.x * *xsptr++ + a.y * *xsptr++ + a.z * *xsptr++ + a.w * *xsptr;
 *     }
 *     __syncthreads();
 * 
 *     int remain = (n - i) & 63;
 * 
 *     if ((tx << 2) < remain) {
 *         a = tex2D(fTexRefA, tx + (i >> 2) + (j << 4), ay);
 *         *Psptr += a.x * *xsptr++;
 *     }
 *     if ((tx << 2) + 1 < remain) *Psptr += a.y * *xsptr++;
 *     if ((tx << 2) + 2 < remain) *Psptr += a.z * *xsptr++;
 *     if ((tx << 2) + 3 < remain) *Psptr += a.w * *xsptr;
 *     __syncthreads();
 * 
 *     if (tx < 8) *Psptr += *(Psptr + 8);
 *     if (tx < 4) *Psptr += *(Psptr + 4);
 *     if (tx < 2) *Psptr += *(Psptr + 2);
 *     if (tx < 1) *Psptr += *(Psptr + 1);
 *     __syncthreads();
 * 
 *     if (ty == 0 && (bx << 4) + tx < m) y[(bx << 4) + tx] = Ps[tx][0];
 * }
 * 
 * 
 * 
@endcode
 <a name="plain-Kernel_mv_fujimoto_T"></a>
@code
 * template<typename T>
 * struct IsFloat;
 * 
 * template<>
 * struct IsFloat<float>
 * {
 *     static const bool value = true;
 * };
 * 
 * template<typename T>
 * struct IsFloat
 * {
 *     static const bool value = false;
 * };
 * 
 * template<typename T>
 * struct TexEl;
 * 
 * template<>
 * struct TexEl<float>
 * {
 *     typedef float4 value_type;
 *     typedef float4 alt_value_type;
 *     typedef float4 texel_type;
 *     static const int tex_stride = 4;
 * };
 * 
 * template<>
 * struct TexEl<double>
 * {
 *     typedef double4 value_type;
 *     typedef double2 alt_value_type;
 *     typedef int4 texel_type;
 *     static const int tex_stride = 2;
 * };
 * 
 * texture<TexEl<double>::texel_type, 2, cudaReadModeElementType> dTexRefA;
 * 
 * 
 * template<typename T>
 * struct texAccessor {
 * 
 *     __device__
 *     typename TexEl<T>::value_type
 *     operator() (int ax, int ay);
 * 
 * };
 * 
 * template<>
 * TexEl<float>::value_type texAccessor<float>::operator() (int ax, int ay)
 * {
 *     return tex2D(fTexRefA, ax, ay);
 * }
 * 
 * template<>
 * TexEl<double>::value_type texAccessor<double>::operator() (int ax, int ay)
 * {
 *     TexEl<double>::texel_type tmp;
 *     TexEl<double>::value_type a;
 * 
 *     tmp = tex2D(dTexRefA, 2*ax, ay);
 *     a.x = __hiloint2double(tmp.y, tmp.x);
 *     a.y = __hiloint2double(tmp.w, tmp.z);
 * 
 *     tmp = tex2D(dTexRefA, 2*ax+1, ay);
 *     a.z = __hiloint2double(tmp.y, tmp.x);
 *     a.w = __hiloint2double(tmp.w, tmp.z);
 * 
 * #ifndef nDEBUG
 *     printf("a : %f, %f, %f, %f\n", a.x, a.y, a.z, a.w);
 * #endif
 *     return a;
 * }
 * 
 * template<typename T>
 * __global__
 * void
 * _mv_fujimoto_T( T* y, cudaArray* A, T* x, int m, int n)
 * {
 *     __shared__ T xs[16][16];
 * 
 *     __shared__ T Ps[16][16];
 * 
 *     typename TexEl<T>::value_type a;
 * 
 *     T *Psptr = (T *) Ps + (ty << 4) + tx;
 * 
 *     int ay = (bx << 4) + ty;
 * 
 *     T *xptr = x + (ty << 4) + tx;
 *     T *xsptr = (T *) xs + (tx << 2);
 * 
 *     *Psptr = 0.0f;
 *     int i;
 * 
 *     texAccessor<T> tex_2D;
 * 
 *     for (i = 0; i < (n & ~255); i += 256, xptr += 256)
 *     {
 *         xs[ty][tx] = *xptr;
 *         __syncthreads();
 * 
 *         int ax = tx + (i >> 2);
 * 
 *         a = tex_2D(ax, ay);
 *         *Psptr += a.x * *xsptr         + a.y * *(xsptr +   1) + a.z * *(xsptr +   2) + a.w * *(xsptr +   3);
 * 
 *         a = tex_2D(ax+16, ay);
 *         *Psptr += a.x * *(xsptr +  64) + a.y * *(xsptr +  65) + a.z * *(xsptr +  66) + a.w * *(xsptr +  67);
 * 
 *         a = tex_2D(ax+32, ay);
 *         *Psptr += a.x * *(xsptr + 128) + a.y * *(xsptr + 129) + a.z * *(xsptr + 130) + a.w * *(xsptr + 131);
 * 
 *         a = tex_2D(ax+48, ay);
 *         *Psptr += a.x * *(xsptr + 192) + a.y * *(xsptr + 193) + a.z * *(xsptr + 194) + a.w * *(xsptr + 195);
 * 
 *         __syncthreads();
 *     }
 * 
 *     if (i + (ty << 4) + tx < n) {
 *         xs[ty][tx] = *xptr;
 *     }
 *     __syncthreads();
 * 
 *     int j;
 *     for (j = 0; j < ((n - i) >> 6); j++, xsptr += 61) {
 *         a = tex_2D(tx + (i >> 2) + (j << 4), ay);
 *         *Psptr += a.x * *xsptr++ + a.y * *xsptr++    +     a.z * *xsptr++ + a.w * *xsptr;
 *     }
 *     __syncthreads();
 * 
 *     int remain = (n - i) & 63;
 *     if ((tx << 2) < remain) {
 *         a = tex_2D(tx + (i >> 2) + (j << 4), ay);
 * 
 *         *Psptr += a.x * *xsptr++;
 *     }
 *     if ((tx << 2) + 1 < remain) *Psptr += a.y * *xsptr++;
 *     if ((tx << 2) + 2 < remain) *Psptr += a.z * *xsptr++;
 *     if ((tx << 2) + 3 < remain) *Psptr += a.w * *xsptr;
 *     __syncthreads();
 * 
 * 
 *     if (tx < 8) *Psptr += *(Psptr + 8);
 *     if (tx < 4) *Psptr += *(Psptr + 4);
 *     if (tx < 2) *Psptr += *(Psptr + 2);
 *     if (tx < 1) *Psptr += *(Psptr + 1);
 * 
 *     __syncthreads();
 *     if (ty == 0 && (bx << 4) + tx < m) y[(bx << 4) + tx] = Ps[tx][0];
 * }
 * 
 * 
@endcode
 <a name="plain-Kernel_mv_fujimoto_T2"></a>
@code
 * template<typename T>
 * __global__
 * void
 * _mv_fujimoto_T2( T* y, cudaArray* A, T* x, int m, int n)
 * {
 *     __shared__ T xs[16][16];
 * 
 *     __shared__ T Ps[16][16];
 * 
 *     typename TexEl<T>::value_type a;
 * 
 *     T *Psptr = (T *) Ps + (16*ty) + tx;
 * 
 *     int ay = (16*bx) + ty;
 * 
 *     T *xptr = x + (16*ty) + tx;
 *     T *xsptr = (T *) xs + (4*tx);
 * 
 *     *Psptr = 0.0f;
 *     int i;
 * 
 *     texAccessor<T> tex_2D;
 * 
 * 
 *     for (i = 0; i < (n & ~255); i += 256, xptr += 256)
 *     {
 *         xs[ty][tx] = *xptr;
 *         __syncthreads();
 * 
 *         int ax = tx + (i/4);
 * 
 *         a = tex_2D(ax, ay);
 *         *Psptr += a.x * *xsptr         + a.y * *(xsptr +   1) + a.z * *(xsptr +   2) + a.w * *(xsptr +   3);
 * 
 *         a = tex_2D(ax+16, ay);
 *         *Psptr += a.x * *(xsptr +  64) + a.y * *(xsptr +  65) + a.z * *(xsptr +  66) + a.w * *(xsptr +  67);
 * 
 *         a = tex_2D(ax+32, ay);
 *         *Psptr += a.x * *(xsptr + 128) + a.y * *(xsptr + 129) + a.z * *(xsptr + 130) + a.w * *(xsptr + 131);
 * 
 *         a = tex_2D(ax+48, ay);
 *         *Psptr += a.x * *(xsptr + 192) + a.y * *(xsptr + 193) + a.z * *(xsptr + 194) + a.w * *(xsptr + 195);
 * 
 *         __syncthreads();
 *     }
 * 
 *     if (i + (16*ty) + tx < n) {
 *         xs[ty][tx] = *xptr;
 *     }
 *     __syncthreads();
 * 
 *     int j;
 *     for (j = 0; j < ((n - i)/64); j++, xsptr += 61) {
 *         a = tex_2D(tx + (i/4) + (16*j), ay);
 *         *Psptr += a.x * *xsptr++ + a.y * *xsptr++    +     a.z * *xsptr++ + a.w * *xsptr;
 *     }
 *     __syncthreads();
 * 
 *     int remain = (n - i) & 63;
 *     if ((4*tx) < remain) {
 *         a = tex_2D(tx + (i/4) + (16*j), ay);
 * 
 *         *Psptr += a.x * *xsptr++;
 *     }
 *     if ((4*tx) + 1 < remain) *Psptr += a.y * *xsptr++;
 *     if ((4*tx) + 2 < remain) *Psptr += a.z * *xsptr++;
 *     if ((4*tx) + 3 < remain) *Psptr += a.w * *xsptr;
 *     __syncthreads();
 * 
 * 
 *     if (tx < 8) *Psptr += *(Psptr + 8);
 *     if (tx < 4) *Psptr += *(Psptr + 4);
 *     if (tx < 2) *Psptr += *(Psptr + 2);
 *     if (tx < 1) *Psptr += *(Psptr + 1);
 * 
 *     __syncthreads();
 *     if (ty == 0 && (16*bx) + tx < m) y[(16*bx) + tx] = Ps[tx][0];
 * }
 * 
 * 
@endcode
 <a name="plain-Kernel_mv_fujimoto_T3"></a>
@code
 * template<typename T>
 * struct texAccessorOpt {
 * 
 *     __device__
 *     typename TexEl<T>::alt_value_type
 *     operator() (int ax, int ay);
 * 
 * };
 * 
 * template<>
 * TexEl<float>::alt_value_type texAccessorOpt<float>::operator() (int ax, int ay)
 * {
 *     return tex2D(fTexRefA, ax, ay);
 * }
 * 
 * template<>
 * TexEl<double>::alt_value_type texAccessorOpt<double>::operator() (int ax, int ay)
 * {
 *     TexEl<double>::texel_type tmp;
 *     TexEl<double>::alt_value_type a;
 * 
 *     tmp = tex2D(dTexRefA, ax, ay);
 *     a.x = __hiloint2double(tmp.y, tmp.x);
 *     a.y = __hiloint2double(tmp.w, tmp.z);
 * 
 * #ifdef DEBUG
 *     printf("a : %f, %f\n", a.x, a.y);
 * #endif
 *     return a;
 * }
 * 
 * template<typename T>
 * __global__
 * void
 * _mv_fujimoto_T3( T* y, cudaArray* A, T* x, int m, int n)
 * {
 *     __shared__ T xs[16][16];
 * 
 *     __shared__ T Ps[16][16];
 * 
 * 
 *     T *Psptr = (T *) Ps + (16*ty) + tx;
 * 
 *     int ay = (16*bx) + ty;
 * 
 *     T *xptr = x + (16*ty) + tx;
 * 
 * 
 *     *Psptr = 0.0f;
 *     int i;
 * 
 *     if(IsFloat<T>::value==true)
 *     {
 *         T *xsptr = (T *) xs + (4*tx);
 *         typename TexEl<T>::value_type a;
 *         texAccessor<T> tex_2D;
 *         for (i = 0; i < (n & ~255); i += 256, xptr += 256)
 *         {
 *             xs[ty][tx] = *xptr;
 *             __syncthreads();
 * 
 *             int ax = tx + (i/4);
 * 
 *             a = tex_2D(ax, ay);
 *              printf("a : %f, %f, %f, %f\n", a.x, a.y, a.z, a.w);
 *             *Psptr += a.x * *xsptr         + a.y * *(xsptr +   1) + a.z * *(xsptr +   2) + a.w * *(xsptr +   3);
 * 
 *             a = tex_2D(ax+16, ay);
 *             *Psptr += a.x * *(xsptr +  64) + a.y * *(xsptr +  65) + a.z * *(xsptr +  66) + a.w * *(xsptr +  67);
 * 
 *             a = tex_2D(ax+32, ay);
 *             *Psptr += a.x * *(xsptr + 128) + a.y * *(xsptr + 129) + a.z * *(xsptr + 130) + a.w * *(xsptr + 131);
 * 
 *             a = tex_2D(ax+48, ay);
 *             *Psptr += a.x * *(xsptr + 192) + a.y * *(xsptr + 193) + a.z * *(xsptr + 194) + a.w * *(xsptr + 195);
 * 
 *             __syncthreads();
 *         }
 * 
 *         if (i + (16*ty) + tx < n) {
 *             xs[ty][tx] = *xptr;
 *         }
 *         __syncthreads();
 * 
 * 
 *         int j;
 *         for (j = 0; j < ((n - i)/64); j++, xsptr += 61) {
 *             a = tex_2D(tx + (i/4) + (16*j), ay);
 *             *Psptr += a.x * *xsptr++ + a.y * *xsptr++ + a.z * *xsptr++ + a.w * *xsptr;
 *         }
 *         __syncthreads();
 * 
 * 
 *         int remain = (n - i) & 63;
 *         if ((4*tx) < remain) {
 *             a = tex_2D(tx + (i/4) + (16*j), ay);
 * 
 *             *Psptr += a.x * *xsptr++;
 *         }
 *         if ((4*tx) + 1 < remain) *Psptr += a.y * *xsptr++;
 *         if ((4*tx) + 2 < remain) *Psptr += a.z * *xsptr++;
 *         if ((4*tx) + 3 < remain) *Psptr += a.w * *xsptr;
 *         __syncthreads();
 *     }
 *     else {
 *         T *xsptr = (T *) xs + (2*tx);
 * 
 *         typename TexEl<T>::alt_value_type a;
 * 
 *         texAccessorOpt<T> tex_2D;
 * 
 *         for (i = 0; i < (n & ~255); i += 256, xptr += 256)
 *         {
 *             xs[ty][tx] = *xptr;
 * 
 *             __syncthreads();
 * 
 *             int ax = tx + (i/2);
 * 
 * 
 *             a = tex_2D(ax, ay);
 *             *Psptr += a.x * *xsptr         + a.y * *(xsptr +   1);
 * 
 *             a = tex_2D(ax+16, ay);
 *             *Psptr += a.x * *(xsptr +  32) + a.y * *(xsptr +  33);
 * 
 *             a = tex_2D(ax+32, ay);
 *             *Psptr += a.x * *(xsptr + 64) + a.y * *(xsptr + 65);
 * 
 *             a = tex_2D(ax+48, ay);
 *             *Psptr += a.x * *(xsptr + 96) + a.y * *(xsptr + 97);
 * 
 *             a = tex_2D(ax+64, ay);
 *             *Psptr += a.x * *(xsptr + 128) + a.y * *(xsptr + 129);
 * 
 *             a = tex_2D(ax+80, ay);
 *             *Psptr += a.x * *(xsptr + 160) + a.y * *(xsptr + 161);
 * 
 *             a = tex_2D(ax+96, ay);
 *             *Psptr += a.x * *(xsptr + 192) + a.y * *(xsptr + 193);
 * 
 *             a = tex_2D(ax+112, ay);
 *             *Psptr += a.x * *(xsptr + 224) + a.y * *(xsptr + 225);
 * 
 *             __syncthreads();
 *         }
 * 
 *         if (i + (16*ty) + tx < n) xs[ty][tx] = *xptr;
 * 
 *         __syncthreads();
 * 
 * 
 *         int j;
 * 
 *         for (j = 0; j < ((n - i)/32); j++, xsptr += 31)
 *         {
 *             a = tex_2D(tx + (i/2) + (16*j), ay);
 *             *Psptr += a.x * *xsptr++ + a.y * *xsptr;
 *         }
 *         __syncthreads();
 * 
 * 
 *         int remain = (n - i) & 31;
 * 
 *         if ((2*tx) < remain) {
 *             a = tex_2D(tx + (i/2) + (16*j), ay);
 * 
 *             *Psptr += a.x * *xsptr++;
 *         }
 * 
 *         if ( (2*tx) + 1 < remain)
 *         {
 *             *Psptr += a.y * *xsptr;
 *         }
 * 
 *         __syncthreads();
 *     }
 * 
 *     if (tx < 8) *Psptr += *(Psptr + 8);
 *     if (tx < 4) *Psptr += *(Psptr + 4);
 *     if (tx < 2) *Psptr += *(Psptr + 2);
 *     if (tx < 1) *Psptr += *(Psptr + 1);
 * 
 *     __syncthreads();
 *     if (ty == 0 && (16*bx) + tx < m) y[(16*bx) + tx] = Ps[tx][0];
 * }
 * 
 * 
@endcode
 <a name="plain-Functionmv_fujimoto"></a>
@code
 * void __do_FJ_orig(float* d_y, cudaArray* d_A, float* d_x, int m, int n, dim3 grid, dim3 threads)
 * {
 *     _mv_fujimoto<<< grid, threads >>>(d_y, d_A, d_x, m, n);
 * }
 * 
 * void __do_FJ_orig(double* , cudaArray* , double* , int , int , dim3 , dim3 )
 * {
 *     printf("For double precision the original version of Fujimoto is not available!\n");
 * }
 * 
 * template<typename T>
 * void Kernels<T>::mv_fujimoto(T *y, const T *A, const T *x, const int m, const int n,
 *                              const int n_repetitions,
 *                              const int fj_version,
 *                              double&  elapsed_time)
 * {
 * 
 *     int blkNum = (m + 15)/16; // (m >> 4) + ((m & 15) ? 1 : 0);
 *     int height = blkNum*16; // blkNum << 4;
 * 
 *     int width = 256*((n+255)/256); // (n & 255) ? (((n >> 8) + 1) << 8) : n;
 * 
 *     dim3 threads(16, 16);
 *     dim3 grid(blkNum, 1);
 * 
 *     cudaArray *d_A;
 *     T *d_x, *d_y;
 * 
 *     cudaChannelFormatDesc
 *             channelDesc = cudaCreateChannelDesc<typename TexEl<T>::texel_type/ *float4* />();
 * 
 *     cudaMallocArray(&d_A, &channelDesc, width/TexEl<T>::tex_stride, height);
 * 
 *     size_t size_of_T = sizeof(T);
 * 
 *     cudaMemcpy2DToArray(d_A, 0, 0, A,
 *                         n * size_of_T,
 *                         n * size_of_T,
 *                         m,
 *                         cudaMemcpyHostToDevice);
 * 
 * 
 *     if (IsFloat<T>::value)
 *         cudaBindTextureToArray(fTexRefA, d_A);
 *     else
 *         cudaBindTextureToArray(dTexRefA, d_A);
 * 
 *     cudaMalloc((void **) &d_x, n * size_of_T );
 *     cudaMalloc((void **) &d_y, m * size_of_T );
 * 
 *     cudaMemcpy(d_x, x, n * size_of_T, cudaMemcpyHostToDevice);
 * 
 * #ifndef DONT_USE_CUDATIMER
 *     CUDATimer timer;
 * #endif
 *     for (int i=0; i<n_repetitions; i++)
 *     {
 *         cudaMemcpy(d_y, y, m * size_of_T, cudaMemcpyHostToDevice);
 *         switch (fj_version) {
 *         case 0:
 *             __do_FJ_orig(d_y, d_A, d_x, m, n, grid, threads);
 *             break;
 *         case 1:
 *             _mv_fujimoto_T<<< grid, threads >>>(d_y, d_A, d_x, m, n);
 *             break;
 *         case 2:
 *             _mv_fujimoto_T2<<< grid, threads >>>(d_y, d_A, d_x, m, n);
 *             break;
 *         case 3:
 *             _mv_fujimoto_T3<<< grid, threads >>>(d_y, d_A, d_x, m, n);
 *             break;
 *         default:
 *             break;
 *         }
 *     }
 *     cudaThreadSynchronize();
 * #ifndef DONT_USE_CUDATIMER
 *     timer.stop();
 *     elapsed_time = timer.elapsed() ;
 * #else
 *     elapsed_time = 3.1415926;
 * #endif
 * #ifdef DEBUG
 * #ifndef DONT_USE_CUDATIMER
 *     timer.print_elapsed("Time spent in Fujimotos MV product:");
 * #endif
 * #endif
 * 
 *     cudaMemcpy(y, d_y, m * size_of_T, cudaMemcpyDeviceToHost);
 * 
 *     cudaFree(d_y);
 *     cudaFree(d_x);
 * 
 *     if(IsFloat<T>::value)
 *         cudaUnbindTexture( fTexRefA);
 *     else
 *         cudaUnbindTexture( dTexRefA);
 *     cudaFreeArray(d_A);
 * }
 * 
 * template class Kernels<float>;
 * template class Kernels<double>;
 * 
 * } // namespace step2 END
 * 
 * 
 * 
 * 
 * 
 @endcode
